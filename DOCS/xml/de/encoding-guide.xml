<?xml version="1.0" encoding="iso-8859-1"?>
<!-- In sync with r18457 -->
<chapter id="encoding-guide">
<title>Encodieren mit <application>MEncoder</application></title>

<sect1 id="menc-feat-dvd-mpeg4">
<title>Erzeugen eines hochwertigen MPEG-4-Rips (&quot;DivX&quot;) eines DVD-Films</title>

<para>
  Eine häufig gestellte Frage ist &quot;Wie mache ich den hochwertigsten
  Rip für eine gegebene Größe?&quot;. Eine weitere Frage ist &quot;Wie mache ich den qualitativ
  bestmöglichen DVD-Rip? Die Dateigröße ist mir egal, ich will einfach nur
  die beste Qualität.&quot;
</para>

<para>
  Die letzte Frage ist zumindest etwas falsch gestellt. Wenn du dir
  schließlich keine Gedanken um die Dateigröße machst, warum kopierst Du
  dann nicht einfach den kompletten MPEG-2-Videostream der DVD?
  Sicherlich, deine AVI wird am Ende 5GB groß sein, so oder so, jedoch ist
  dies mit Sicherheit deine beste Option, wenn du die beste Qualität
  erhalten willst und dich nicht um die Größe kümmerst.
</para>

<para>
  Tatsache ist, der Grund eine DVD in MPEG-4 umzuencodieren ist
  gerade <emphasis role="bold">weil</emphasis> dir die Größe wichtig ist.
</para>

<para>
  Es ist sehr schwierig, ein Rezept zum Erzeugen eines sehr
  hochwertigen DVD-Rips anzubieten. Es gilt mehrere Faktoren zu
  berücksichtigen, und du solltest dich mit diesen Details auskennen oder
  du wirst voraussichtlich am Ende von den Resultaten enttäuscht.
  Nachfolgend werden wir einige dieser Themen etwas näher untersuchen
  und uns danach ein Beispiel ansehen. Wir gehen davon aus, dass Du
  <systemitem class="library">libavcodec</systemitem> zum Encodieren des
  Videos verwendest, obwohl diese Theorie genauso gut auf andere Codecs
  zutrifft.
</para>

<para>
  Ist dies alles zu viel für dich, solltest du womöglich auf eins der vielen
  guten Frontends zurückgreifen, die in der
  <ulink url="http://www.mplayerhq.hu/design7/projects.html#mencoder_frontends">MEncoder-Sektion</ulink>
  unserer diesbezüglichen Projektseite zu finden sind.
  Auf diese Weise solltest du in der Lage sein, hochwertige Rips zu
  erhalten ohne viel nachdenken zu müssen, da die meisten dieser Tools dazu entworfen
  wurden, clevere Entscheidungen für dich zu treffen.
</para>

<sect2 id="menc-feat-dvd-mpeg4-preparing-encode">
<title>Vorbereitung aufs Encodieren: Identifiziere Quellmaterial und Framerate</title>
<para>
  Bevor du über das Encodieren eines Films nachdenkst, solltest du einige einleitende
  Schritte vornehmen.
</para>

<para>
  Der erste und allerwichtigste Schritt vor dem Encodieren sollte sein,
  festzustellen, mit welchem Inhaltstyp du umgehst.
  Kommt dein Quellmaterial von einer DVD oder einem Rundfunk-/Kabel-/Satelliten-TV,
  wird es in einem von zwei Formaten abgespeichert: NTSC für Nord-Amerika und Japan,
  PAL für Europa usw.
  Es ist wichtig, sich klar zu machen, dass dies ganz einfach die Formatierung
  für die Präsentation auf einem Fernsehgerät ist und häufig
  <emphasis role="bold">nicht</emphasis> mit dem originalen Format des Films
  korrespondiert. Die Erfahrung zeigt, dass NTSC-Material schwieriger zu
  encodieren ist, da mehr Elemente in der Quelle zu identifizieren sind.
  Um eine geeignete Encodierung zu produzieren, solltest du das originale
  Format kennen.
  Fehler, dies sollte man berücksichtigen, führen zu diversen Fehlerstellen
  in deiner Encodierung, einschließlich hässlicher Kammartefakte (combing/interlacing)
  und doppelten oder gar verlorenen Frames.
  Abgesehen davon, dass sie unschön sind, beeinflussen diese Artefakte die
  Codierungseffizienz negativ:
  Du erhältst eine schlechtere Qualität pro Bitrateneinheit.
</para>

<sect3 id="menc-feat-dvd-mpeg4-preparing-encode-fps">
<title>Identifizieren der Quellframerate</title>
<para>
  Hier ist eine Liste der verbreiteten Typen des Quellmaterials, in der Du
  diese und ihre Eigenschaften voraussichtlich finden wirst:
</para>
<itemizedlist>
<listitem><para>
  <emphasis role="bold">Standardfilm</emphasis>: Produziert für
  theatralische Anzeige bei 24fps.
</para></listitem>
<listitem><para>
  <emphasis role="bold">PAL-Video</emphasis>: Aufgenommen mit einer
  PAL-Videokamera bei 50 Feldern pro Sekunde.
  Ein Feld besteht ganz einfach aus den ungerade oder gerade nummerierten
  Zeilen eines Frames.
  Das Fernsehen wurde entworfen, diese Felder als billige Form einer
  analogen Komprimierung im Wechsel zu aktualisieren.
  Das menschliche Auge kompensiert dies angeblich, aber wenn du
  Interlacing einmal verstanden hast, wirst du lernen, es auch auf
  dem TV-Bildschirm zu erkennen und nie wieder Spass am Fernsehen haben.
  Zwei Felder machen <emphasis role="bold">keinen</emphasis> kompletten
  Frame, da sie in einer 50-stel Sekunde zeitlich getrennt aufgenommen
  werden und so nicht Schlange stehen solange keine Bewegung da ist.
</para></listitem>
<listitem><para>
  <emphasis role="bold">NTSC-Video</emphasis>: Aufgenommen mit einer
  NTSC-Videokamera bei 60000/1001 Feldern pro Sekunde oder 60 Feldern
  pro Sekunde zu Zeiten vor dem Farbfernsehen.
  Ansonsten ähnlich wie PAL.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Animation</emphasis>: Üblicherweise bei
  24fps gezeichnet, kommt jedoch auch in Varianten mit gemischter
  Framerate vor.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Computer Graphics (CG)</emphasis>: Kann
  irgendeine Framerate sein, jedoch sind einige üblicher als andere;
  24 und 30 Frames pro Sekunde sind typisch für NTSC und 25fps ist
  typisch für PAL.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Alter Film</emphasis>: Diverse niedrigere
  Frameraten.
</para></listitem>
</itemizedlist>
</sect3>

<sect3 id="menc-feat-dvd-mpeg4-preparing-encode-material">
<title>Identifizieren des Quellmaterials</title>
<para>
  Filme, die sich aus Frames zusammensetzen, werden den progressiven
  zugeordnet, während die aus unabhängigen Feldern bestehenden
  entweder interlaced (engl. für verschachteln) oder Video
  genannt werden - somit ist letzterer Terminus zweideutig.
</para>
<para>
  Um das ganze noch komplizierter zu machen, sind manche Filme ein
  Gemisch aus einigen den oben beschriebenen Formen.
</para>
<para>
  Das wichtigste Unterscheidungsmerkmal zwischen all diesen
  Formaten ist, dass einige Frame-basiert, andere wiederum
  Feld-basiert sind.
  <emphasis role="bold">Immer</emphasis> wenn ein Film für die
  Anzeige auf dem Fernseher vorbereitet wird (einschließlich
  DVD), wird er in ein Feld-basiertes Format konvertiert.
  Die zahlreichen Methoden, mit denen dies bewerkstelligt werden
  kann, werden insgesamt dem &quot;pulldown&quot; zugeordnet, von welchem
  das verrufene NTSC &quot;3:2 telecine&quot; eine Abart darstellt.
  Sofern das Originalmaterial nicht Feld-basiert war (bei gleicher
  Feldrate), erhältst du einen Film in einem anderen Format als
  das Original.
</para>

<itemizedlist>
<title>Es gibt einige verbreitete Typen des pulldown:</title>
<listitem><para>
  <emphasis role="bold">PAL 2:2 pulldown</emphasis>: Das schönste von
  allen.
  Jeder Frame wird durch das wechselweise Extrahieren und Anzeigen
  der geradzahligen und ungeradzahligen Zeilen für die Dauer von zwei
  Feldern dargestellt.
  Hat das Originalmaterial 24fps, beschleunigt dieser Prozess den Film
  um 4%.
</para></listitem>
<listitem><para>
  <emphasis role="bold">PAL 2:2:2:2:2:2:2:2:2:2:2:3 pulldown</emphasis>:
  Jeder 12-te Frame, anstatt nur jeder 2-te, wird für die Dauer von zwei
  Feldern dargestellt.
  Dies vermeidet die 4% Geschwindigkeitssteigerung, macht jedoch das
  Umkehren des Prozesses viel schwieriger.
  Es ist üblicherweise in Musical-Produktionen zu sehen, wo das Anpassen der
  Geschwindigkeit um 4% sicherlich das musikalische Ergebnis kaputt machen würde.
</para></listitem>
<listitem><para>
  <emphasis role="bold">NTSC 3:2 telecine</emphasis>: Frames werden
  abwechselnd für die Dauer von 3 oder 2 Feldern angezeigt.
  Dies verleiht der Feldrate das 2.5-fache der originalen Framerate.
  Das Resultat wird dadurch auch leicht von 60 Feldern pro Sekunde auf
  60000/1001 Felder pro Sekunde verlangsamt, um die NTSC-Felddrate
  beizubehalten.
</para></listitem>
<listitem><para>
  <emphasis role="bold">NTSC 2:2 pulldown</emphasis>: Verwendet zur
  Darstellung von 30fps Material auf NTSC.
  Schön, genau wie das 2:2 PAL pulldown.
</para></listitem>
</itemizedlist>

<para>
  Es gibt auch Methoden zur Konvertierung zwischen NTSC- und PAL-Video,
  jedoch liegen diese Themen jenseits des Rahmens dieser Anleitung.
  Wenn du auf solch einen Film stößt und ihn encodieren willst, solltest
  du besser eine Kopie im originalen Format suchen.
  Die Konvertierung zwischen diesen beiden Formaten ist hochdestruktiv und
  kann nicht spurlos rückgängig gemacht werden, somit wird deine Encodierung
  außerordentlich darunter leiden, wenn sie aus einer konvertierten Quelle
  erzeugt wurde.
</para>
<para>
  Wenn ein Video auf DVD gespeichert wird, werden fortlaufend Feldpaare
  als Frames gruppiert, auch wenn nicht beabsichtigt ist, diese gleichzeitig
  zu zeigen.
  Der bei DVD und digitalem TV verwendete MPEG-2-Standard bietet einen Weg
  für beides, die originalen progressiven Frames zu encodieren und die Anzahl
  der Felder, für die ein Frame gezeigt werden soll, im Header dieses Frames
  zu speichern.
  Wurde diese Methode angewandt, wird dieser Film oft als &quot;soft telecined&quot;
  beschrieben, da der Prozess eher nur den DVD-Player anweist, pulldown
  auf den Film anzuwenden, als den Film selbst abzuändern.
  Dieser Fall sollte möglichst bevorzugt werden, da er (eigentlich ignoriert)
  leicht vom Encoder rückgängig gemacht werden kann und da er die maximale
  Qualität beibehält.
  Wie auch immer, viele DVD- und Rundfunkproduktionsstudios verwenden
  keine passenden Encodierungstechniken, sie produzieren stattdessen Filme mit
  &quot;hard telecine&quot;, bei denen Felder sogar in encodiertes MPEG-2 dupliziert
  werden.
</para>
<para>
  Die Vorgehensweisen für den Umgang mit solchen Fällen werden
  <link linkend="menc-feat-telecine">später in diesem Handbuch</link>
  behandelt.
  Wir lassen dich jetzt mit einigen Anleitungen zur Identifizierung der
  Materialtypen zurück, mit denen du es zu tun hast:
</para>

<itemizedlist>
<title>NTSC-Bereiche:</title>
<listitem><para>
  Wenn <application>MPlayer</application> angibt, dass die Framerate
  während des Betrachtens des Films zu 24000/1001 gewechselt hat
  und diese nie wieder zurückwechselt, handelt es sich meist mit
  Sicherheit um progressiven Inhalt, der &quot;soft telecined&quot; wurde.
</para></listitem>
<listitem><para>
  Wenn <application>MPlayer</application> anzeigt, dass die Framerate
  zwischen 24000/1001 und 30000/1001 vor und zurück wechselt, und Du
  siehst hin und wieder Kammartefakte, dann gibt es mehrere Möglichkeiten.
  Die Segmente mit 24000/1001 fps sind meist mit Sicherheit progressiver
  Inhalt, &quot;soft telecined&quot;, jedoch könnten die Teile mit 30000/1001 fps
  entweder &quot;hard telecined&quot; 24000/1001 fps Inhalt oder 60000/1001 Felder
  pro Sekunde NTSC-Video sein.
  Verwende die selben Richtwerte wie in den folgenden zwei Fällen, um zu
  bestimmen, um was es sich handelt.
</para></listitem>
<listitem><para>
  Wenn <application>MPlayer</application> nie einen Frameratenwechsel
  anzeigt und jeder einzelne Frame mit Bewegung gekämmt (combed) erscheint,
  ist dein Film ein NTSC-Video bei 60000/1001 Feldern pro Sekunde.
</para></listitem>
<listitem><para>
  Wenn <application>MPlayer</application> nie einen Frameratenwechsel
  anzeigt und zwei von fünf Frames gekämmt (combed) erscheinen, ist der
  Inhalt deines Films &quot;hard telecined&quot; 24000/1001 fps.
</para></listitem>
</itemizedlist>

<itemizedlist>
<title>PAL-Bereiche:</title>
<listitem><para>
  Wenn du niemals irgend ein Combing siehst, ist dein Film 2:2 pulldown.
</para></listitem>
<listitem><para>
  Siehst du alle halbe Sekunde abwechselnd ein- und ausgehendes Combing,
  dann ist dein Film 2:2:2:2:2:2:2:2:2:2:2:3 pulldown.
</para></listitem>
<listitem><para>
  Hast du immer während Bewegungen Combing gesehen, dann ist dein Film
  PAL-Video bei 50 Feldern pro Sekunde.
</para></listitem>
</itemizedlist>

<note><title>Tipp:</title>
<para>
  <application>MPlayer</application> kann das Filmplayback
  mittels der Option -speed verlangsamen oder Frame für Frame abspielen.
  Versuche <option>-speed</option> 0.2 zu verwenden, um den Film sehr lamgsam
  anzusehen oder drücke wiederholt die Taste &quot;<keycap>.</keycap>&quot;, um jeweils
  einen Frame abzuspielen und identifiziere dann das Muster, falls du bei voller
  Geschwindigkeit nichts erkennen kannst.
</para>
</note>
</sect3>
</sect2>

<sect2 id="menc-feat-dvd-mpeg4-2pass">
<title>Konstanter Quantisierungsparameter vs. Multipass</title>

<para>
  Es ist möglich, deinen Film in einer großen Auswahl von Qualitäten zu
  encodieren.
  Mit modernen Videoencodern und ein wenig Pre-Codec-Kompression
  (Herunterskalierung und Rauschunterdrückung), kann eine sehr gute
  Qualität bei 700 MB für einen 90-110-minütigen Breitwandfilm erreicht werden.
  Des Weiteren können alle Filme - sogar die längsten - mit nahezu perfekter
  Qualität bei 1400 MB encodiert werden.
</para>

<para>
  Es gibt drei Annäherungen für das Encodieren eines Videos: konstante Bitrate
  (CBR), konstanter Quantisierungsparameter und Multipass (ABR, oder mittlere Bitrate).
</para>

<para>
  Die Komplexität der Frames eines Filmes und somit die Anzahl der für
  deren Komprimierung erforderlichen Bits kann von einer Szene zur anderen
  außerordentlich variieren.
  Moderne Videoencoder können sich durch Variieren der Bitrate an diese
  Anforderungen anpassen.
  In einfachen Modi wie CBR kennen die Encoder jedoch nicht den
  Bitratenbedarf zukünftiger Szenen und sind somit nicht in der Lage,
  die angeforderte mittlere Bitrate über längere Zeitspannen zu
  überschreiten.
  Erweiterte Modi wie etwa Multipass-Encodierung können die Statistik
  früherer Durchgänge berücksichtigen; dies behebt das oben erwähnte
  Problem.
</para>

<note><title>Anmerkung:</title>
<para>
  Die meisten Codecs, die ABR-Encodierung unterstützen, unterstützen nur
  die Encodierung in zwei Durchgängen (two pass) während einige andere wie
  etwa <systemitem class="library">x264</systemitem>,
  <systemitem class="library">XviD</systemitem>
  und <systemitem class="library">libavcodec</systemitem> Multipass
  unterstützen, was die Qualität bei jedem Durchgang leicht verbessert.
  Jedoch ist diese Verbesserung weder messbar noch ist sie nach dem
  4-ten Durchgang oder so spürbar.
  Aus diesem Grund werden in diesem Abschnitt die Encoderierung mit 2 Durchläufen
  (two pass) und Multipass abwechselnd angewandt.
</para>
</note>

<para>
  In jedem dieser Modi bricht der Videocodec (wie etwa
  <systemitem class="library">libavcodec</systemitem>)
  den Videoframe in 16x16 Pixel Macroblöcke und wendet danach einen
  Quantisierer auf jeden Macroblock an. Je niedriger der Quantisierer desto
  besser die Qualität und desto höher die Bitrate.
  Die Methode, die der Filmencoder zur Bestimmung des auf einen gegebenen
  Macroblock anzuwendenden Quantisierer verwendet, variiert und ist in
  hohem Maße einstellbar. (Dies ist eine extrem übertriebene Vereinfachung
  des aktuellen Prozesses aber nützlich, um das Grundkonzept zu verstehen.)
</para>

<para>
  Wenn du eine konstante Bitrate festlegst, wird der Videocodec das Video
  so encodieren, dass so viele Details wie notwendig und so wenig
  wie möglich ausgesondert werden, um unterhalb der vorgegebenen Bitrate zu
  bleiben. Wenn du dich wirklich nicht um die Dateigröße kümmerst, könntest
  du auch CBR verwenden und eine nahezu endlose Bitrate festlegen.
  (In der Praxis bedeutet dies einen Wert, der hoch genug ist, kein Limit
  aufzuwerfen wie 10000Kbit.) Ohne echte Einschränkung der Bitrate wird
  der Codec als Ergebnis den niedrigsten möglichen Quantisierer für jeden
  Macroblock anwenden (wie durch <option>vqmin</option> für
  <systemitem class="library">libavcodec</systemitem>
  spezifiziert, Standardwert ist 2).
  Sobald du eine Bitrate festlegst, die niedrig genug ist, den
  Codec zur Anwendung eines höheren Quantisierers zu zwingen, bist Du
  nahezu sicher dabei, die Qualität deines Videos zu ruinieren.
  Um dies zu vermeiden, solltst du möglicherweise dein Video wie
  in der später in diesem Handbuch beschriebenen Methode reduzieren.
  Im Allgemeinen solltst du CBR vollkommen meiden, wenn dir Qualität
  wichtig ist.
</para>

<para>
  Mit konstantem Quantisierer wendet der Codec denselben Quantisierer, wie
  durch die Option <option>vqscale</option> (für
  <systemitem class="library">libavcodec</systemitem>) spezifiziert, auf jeden
  Macroblock an.
  Willst du einen Rip mit höchstmöglicher Qualität und ignorierst dabei
  wiederum die Bitrate, kannst du <option>vqscale=2</option> verwenden.
  Dies wird dieselbe Bitrate und PSNR (peak signal-to-noise ratio) liefern
  wie CBR mit <option>vbitrate</option>=infinity und der Standardeinstellung
  <option>vqmin</option>=2.
</para>

<para>
  Das Problem mit konstantem Quantisierer ist, dass der vorgegebene Quantisierer
  zum Einsatz kommt, egal ob der Macroblock ihn benötigt oder nicht. Dies heißt,
  es wäre möglich, einen höheren Quantisierer auf einen Macroblock anzuwenden,
  ohne sichtbare Qualität zu opfern. Warum die Bits für einen unnötig kleinen
  Quantisierer verschwenden? Deine CPU hat soundso viele Arbeitsgänge Zeit zur
  Verfügung, die Festplatte jedoch nur soundso viele Bits.
</para>

<para>
  Bei einer Encodierung mit zwei Durchläufen (two pass), wird der erste Durchgang
  den Film so rippen, als würde CBR vorliegen, jedoch wird ein Log die Eigenschaften
  jedes Frames beibehalten. Diese Daten werden danach während des zweiten Durchgangs
  dazu verwendet, intelligente Entscheidungen zur Wahl des Quantisierers zu treffen.
  Während schneller Action oder hochdetaillierter Szenen werden womöglich
  höhere Quantisierer, während langsamen Bewegungen und Szenen mit weniger Details
  niedrigere Quantisierer verwendet.
  Normalerweise ist die Anzahl der Bewegungen wichtiger als die der Details.
</para>

<para>
  Wenn du <option>vqscale=2</option> verwendest, verschwendest du Bits. Wenn
  du <option>vqscale=3</option> anwendest, wirst du keinen Rip mit bestmöglicher
  Qualität erhalten. Angenommen du rippst eine DVD mit <option>vqscale=3</option>
  und das Resultat ist 1800Kbit. Wenn du in zwei Durchgängen mit
  <option>vbitrate=1800</option> encodierst, wird das daraus resultierende Video
  eine <emphasis role="bold">bessere Qualität</emphasis> bei
  <emphasis role="bold">gleicher Bitrate</emphasis> haben.
</para>

<para>
  Da du nun davon überzeugt bist, dass zwei Durchgänge (two pass) den besten
  Weg darstellen, stellt sich jetzt tatsächlich die Frage, welche Bitrate
  verwendet werden soll? Die Antwort ist, dass es nicht nur eine
  Antwort gibt. Idealerweise willst du eine Bitrate wählen, die die beste Balance
  zwischen Qualität und Dateigröße ergibt. Die kann abhängig vom Quellvideo
  variieren.
</para>

<para>
  Interessiert die Größe nicht, stellen etwa 2000Kbit plus oder minus 200Kbit
  einen guten Ausgangspunkt für einen sehr hochqualitativen Rip dar.
  Bei einem Video mit schneller Action oder hohen Details, oder wenn du schlicht
  und ergreifend ein sehr kritisches Auge besitzst, könntest du dich für 2400
  oder 2600 entscheiden.
  Bei einigen DVDs kannst du eventuell keinen Unterschied bei 1400Kbit feststellen.
  Um ein besseres Gefühl zu bekommen, ist es eine gute Idee, mit Szenen bei
  unterschiedlichen Bitraten herumzuexperimentieren.
</para>

<para>
  Wenn du eine bestimmte Größe anvisierst, musst du die Bitrate irgendwie
  kalkulieren.
  Aber zuvor solltest du wissen, wieviel Platz du für den/die Audiotrack(s)
  reservieren musst, daher solltest Du
  <link linkend="menc-feat-dvd-mpeg4-audio">diese(n) zuerst rippen</link>.
  Du kannst die Bitrate mit folgender Gleichung berechnen:
  <systemitem>Bitrate = (zielgroesse_in_MByte - soundgroesse_in_MByte) *
  1024 * 1024 / laenge_in_sek * 8 / 1000</systemitem>
  Um zum Beispiel einen zweistündigen Film auf eine 702MB CD mit einem 60MB
  Audiotrack zu bekommen, sollte die Videobitrate folgendermaßen sein:
  <systemitem>(702 - 60) * 1024 * 1024 / (120*60) * 8 / 1000
  = 740kbps</systemitem>
</para>

</sect2>


<sect2 id="menc-feat-dvd-mpeg4-constraints">
<title>Randbedingungen für effizientes Encodieren</title>

<para>
  Aufgrund der Natur der MPEG-Komprimierung gibt es zahlreiche
  Randbedingungen, denen du zum Erreichen maximaler Qualität folgen
  solltest.
  MPEG splittet das Video in Macroblöcke genannte 16x16 Quadrate auf,
  jeder davon zusammengesetzt aus 4 8x8 Blöcken mit
  Luma-(Intensitäts)-Informationen und zwei halb-auflösenden 8x8
  Chroma-(Farb)-Blöcken (einer für die Rot-Cyan-Achse und der andere für
  die Blau-Gelb-Achse).
  Selbst wenn Breite und Höhe deines Films kein Vielfaches von 16 sind,
  wird der Encoder ausreichend 16x16 Macroblöcke zur Abdeckung des
  gesamten Bildbereichs verwenden und der Extraplatz wird verschwendet.
  Folglich ist es keine gute Idee, im Interesse der Maximierung der
  Qualität bei fester Dateigröße, Abmessungen zu verwenden, die kein
  Vielfaches von 16 sind.
</para>

<para>
  Die meisten DVDs besitzen ein bestimmtes Maß schwarzer Balken
  an ihren Rändern. Diese dort zu belassen kann die Qualität auf
  verschiedene Art und Weise negativ beeinflussen.
</para>

<orderedlist>
<listitem>
<para>
  MPEG-Kompression hängt ebenso in höchstem Maße von den
  Frequenzbereichs-Transformationen ab, insbesondere von der
  Discrete Cosine Transform (DCT), die der Fourier Transform ähnelt.
  Diese Art Encodierung ist für darstellende Muster und weiche
  Übergänge effizient, hat jedoch große Probleme mit scharfen Kanten.
  Um diese zu encodieren muss sie viel mehr Bits verwenden,
  oder es wird andernfalls ein als Ringing bekannter Artefakt
  auftreten.
</para>

<para>
  Die Discrete Frequency Transform (DCT) erfolgt separat auf jeden
  Macroblock (eigentlich auf jeden Block), somit trifft dieses Problem
  nur zu, wenn sich in einem Block eine scharfe Kante befindet.
  Beginnt dein schwarzer Rand exakt an den Grenzen zum Vielfachen von
  16 Pixeln, stellt dies kein Problem dar.
  Seis drum, die schwarzen Ränder bei DVDs werden in den seltensten
  Fällen schön angeordnet, daher wirst du sie in der Praxis immer
  abschneiden müssen, um diesen Nachteil zu vermeiden.
</para>
</listitem>
</orderedlist>

<para>
  Zusätzlich zu den Frequenzbereichs-Transformationen verwendet die
  MPEG-Kompression Bewegungsvektoren, um den Wechsel von einem Frame
  zum anderen darzustellen.
  Bewegungsvektoren arbeiten bei Inhalt, der von den Kanten eines Bildes
  her einfließt, normalerweise weniger effizient, da dieser im vorherigen
  Frame nicht vorhanden ist. Solange sich das Bild bis voll zur Kante des
  encodierten Bereichs hin vergrößert, haben Bewegungsvektoren kein Problem
  mit Inhalt, der sich aus den Kanten des Bildes hinausbewegt. Die Präsenz
  schwarzer Ränder kann jedoch Ärger machen:
</para>

<orderedlist continuation="continues">
<listitem>
<para>
  Die MPEG-Kompression speichert für jeden Macroblock einen Vektor,
  um ausfindig zu machen, welcher Teil des vorherigen Frames in diesen
  Macroblock als Basis zur Vorhersage des nächsten Frames kopiert
  werden soll. Nur die verbleibenden Unterschiede müssen encodiert werden.
  Überspannt der Macroblock die Kante des Bildes und enthält einen
  Teil des schwarzen Randes, werden Bewegungsvektoren aus anderen
  Teilen des Bildes den schwarzen Rand überschreiben. Dies bedeutet, dass
  jede Menge Bits entweder zur wiederholten Schwärzung des überschriebenen
  Randes aufgewendet werden müssen, oder es wird (eher) erst gar kein
  Bewegungsvektor genutzt und alle Änderungen innerhalb dieses Macroblocks
  müssen explizit encodiert werden. So oder so wird die Encodiereffizienz
  außerordentlich reduziert.
</para>

<para>
  Nochmal, dieses Problem trifft nur dann zu, wenn schwarze Ränder
  nicht an den Grenzen eines Vielfachen von 16 anstehen.
</para>
</listitem>

<listitem>
<para>
  Zuletzt noch was, angenommen wir haben einen Macroblock im Inneren des
  Bildes und ein Objekt bewegt sich aus Richtung Nähe der Kante des Bildes
  her in diesen Block hinein. Die MPEG-Encodierung kann nicht sagen
  &quot;kopiere den Teil, der innerhalb des Bildes liegt, den schwarzen Rand
  aber nicht&quot;. Somit wird der schwarze Rand ebenfalls mit hinein kopiert
  und jede Menge Bits müssen zur Encodierung des Teils des Bildes, der
  dort angenommen wird, aufgewendet werden.
</para>

<para>
  Läuft das Bild ständig zur Kante des encodierten Bereichs hin, besitzt
  MPEG spezielle Optimierungen, um immer wieder dann die Pixel am Rand des
  Bildes zu kopieren, wenn ein Bewegungsvektor von außerhalb des
  encodierten Bereichs ankommt. Dieses Feature wird nutzlos, wenn der Film
  schwarze Ränder hat. Im Gegensatz zu den Problemen 1 und 2 hilft hier
  kein Anordnen der Ränder am Vielfachen von 16.
</para>
</listitem>

<listitem>
<para>
  Obwohl die Ränder komplett schwarz sind und sich nie ändern, ist
  zumindest ein minimaler Overhead damit verbunden, mehr Macroblöcke
  zu besitzen.
</para>
</listitem>
</orderedlist>

<para>
  Aus all diesen Gründen wird empfohlen, schwarze Ränder komplett abzuschneiden.
  Mehr noch, liegt ein Bereich mit Rauschen/Verzerrung an der Kante des Bildes,
  steigert dessen Abschneiden ebenso die Encodiereffizienz. Videophile Puristen,
  die den Originalzustand so nah wie möglich sichern wollen,
  mögen dieses Abschneiden (cropping) beanstanden, wenn du jedoch nicht planst,
  bei konstantem Quantisierer zu encodieren, wird der Qualitätsgewinn, den Du
  durch dieses Abschneiden erreichst, beträchtlich über dem Verlust an Informationen
  an den Kanten liegen.
</para>
</sect2>


<sect2 id="menc-feat-dvd-mpeg4-crop">
<title>Abschneiden und Skalieren</title>

<para>
  Wiederaufruf der vorherigen Sektion, dass die letzte von Dir
  encodierte Bildgröße ein Vielfaches von 16 sein sollte (bei beidem,
  Breite und Höhe).
  Diese kann durch Abschneiden, Skalieren erreicht werden oder durch
  eine Kombination von beidem.
</para>

<para>
  Beim Abschneiden gibt es ein paar Richtwerte, die befolgt werden müssen,
  um eine Zerstörung des Films zu vermeiden.
  Das normale YUV-Format, 4:2:0, speichert Chroma-(Farb)-Informationen
  in einer Unterstichprobe (subsampled), z.B. wird Chroma nur halb so oft
  in jede Richtung gesampelt wie Luma-(Intensitäts)-Informationen.
  Beobachte dieses Diagramm, in dem L Luma-Samplingpunkte bedeuten und C
  für Chroma steht.
</para>

<informaltable>
<?dbhtml table-width="40%" ?>
<?dbfo table-width="40%" ?>
<tgroup cols="8" align="center">
<colspec colnum="1" colname="col1"/>
<colspec colnum="2" colname="col2"/>
<colspec colnum="3" colname="col3"/>
<colspec colnum="4" colname="col4"/>
<colspec colnum="5" colname="col5"/>
<colspec colnum="6" colname="col6"/>
<colspec colnum="7" colname="col7"/>
<colspec colnum="8" colname="col8"/>
<spanspec spanname="spa1-2" namest="col1" nameend="col2"/>
<spanspec spanname="spa3-4" namest="col3" nameend="col4"/>
<spanspec spanname="spa5-6" namest="col5" nameend="col6"/>
<spanspec spanname="spa7-8" namest="col7" nameend="col8"/>
  <tbody>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry spanname="spa1-2">C</entry>
      <entry spanname="spa3-4">C</entry>
      <entry spanname="spa5-6">C</entry>
      <entry spanname="spa7-8">C</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry spanname="spa1-2">C</entry>
      <entry spanname="spa3-4">C</entry>
      <entry spanname="spa5-6">C</entry>
      <entry spanname="spa7-8">C</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
  </tbody>
</tgroup>
</informaltable>

<para>
  Wie du sehen kannst, kommen Zeilen und Spalten des Bildes natürlich paarweise.
  Folglich <emphasis>müssen</emphasis> deine Abschneide-Offsets und
  Abmessungen geradzahlig sein.
  Sind sie dies nicht, wird Chroma nicht mehr korrekt mit Luma abgeglichen.
  In der Theorie ist es möglich, mit ungeraden Offsets abzuschneiden, jedoch
  erfordert dies ein Resampling von Chroma, was potentiell eine mit Verlust
  verbundene Operation bedeutet und vom Crop-Filter nicht unterstützt
  wird.
</para>

<para>
  Weiterhin wird interlaced Video folgendermaßen gesampelt:
</para>

<informaltable>
<?dbhtml table-width="80%" ?>
<?dbfo table-width="80%" ?>
<tgroup cols="16" align="center">
<colspec colnum="1"  colname="col1"/>
<colspec colnum="2"  colname="col2"/>
<colspec colnum="3"  colname="col3"/>
<colspec colnum="4"  colname="col4"/>
<colspec colnum="5"  colname="col5"/>
<colspec colnum="6"  colname="col6"/>
<colspec colnum="7"  colname="col7"/>
<colspec colnum="8"  colname="col8"/>
<colspec colnum="9"  colname="col9"/>
<colspec colnum="10" colname="col10"/>
<colspec colnum="11" colname="col11"/>
<colspec colnum="12" colname="col12"/>
<colspec colnum="13" colname="col13"/>
<colspec colnum="14" colname="col14"/>
<colspec colnum="15" colname="col15"/>
<colspec colnum="16" colname="col16"/>
<spanspec spanname="spa1-2"   namest="col1" nameend="col2"/>
<spanspec spanname="spa3-4"   namest="col3" nameend="col4"/>
<spanspec spanname="spa5-6"   namest="col5" nameend="col6"/>
<spanspec spanname="spa7-8"   namest="col7" nameend="col8"/>
<spanspec spanname="spa9-10"  namest="col9" nameend="col10"/>
<spanspec spanname="spa11-12" namest="col11" nameend="col12"/>
<spanspec spanname="spa13-14" namest="col13" nameend="col14"/>
<spanspec spanname="spa15-16" namest="col15" nameend="col16"/>
  <tbody>
    <row>
      <entry namest="col1" nameend="col8">Oberes Feld</entry>
      <entry namest="col9" nameend="col16">Unteres Feld</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry spanname="spa1-2">C</entry>
      <entry spanname="spa3-4">C</entry>
      <entry spanname="spa5-6">C</entry>
      <entry spanname="spa7-8">C</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry spanname="spa9-10">C</entry>
      <entry spanname="spa11-12">C</entry>
      <entry spanname="spa13-14">C</entry>
      <entry spanname="spa15-16">C</entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry spanname="spa1-2">C</entry>
      <entry spanname="spa3-4">C</entry>
      <entry spanname="spa5-6">C</entry>
      <entry spanname="spa7-8">C</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
    <row>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry spanname="spa9-10">C</entry>
      <entry spanname="spa11-12">C</entry>
      <entry spanname="spa13-14">C</entry>
      <entry spanname="spa15-16">C</entry>
    </row>
    <row>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
      <entry>L</entry>
    </row>
  </tbody>
</tgroup>
</informaltable>

<para>
  Wie du erkennen kannst, wiederholt sich das Muster bis nach 4 Zeilen nicht.
  Somit müssen bei interlaced Video dein y-Offset und die Höhe für das
  Ausschneiden ein Vielfaches von 4 sein.
</para>

<para>
  Die ursprüngliche DVD-Auflösung ist 720x480 für NTSC und 720x576 für PAL, es
  gibt jedoch ein Aspektkennzeichen, das spezifiziert, ob Vollbild (4:3) oder
  Breitwandfilm (16:9) vorliegt. Viele (wenn nicht die meisten) Breitwandfilm-DVDs
  sind nicht grundsätzlich 16:9, sondern entweder 1.85:1 oder 2.35:1 (Cinescope).
  Dies bedeutet, dass es schwarze Bänder im Video geben wird, die herausgeschnitten
  werden müssen.
</para>

<para>
  <application>MPlayer</application> stellt einen Crop-Erkennungsfilter
  zur Verfügung, der das Ausschnittsrechteck (<option>-vf cropdetect</option>)
  bestimmt.
  Starte <application>MPlayer</application> mit
  <option>-vf cropdetect</option>, und er wird die Crop-Einstellungen
  zum Entfernen der Ränder ausgeben.
  du solltest den Film lange genug laufen lassen, damit die gesamte Bildfläche
  verwendet wird, um akkurate Crop-Werte zu erhalten.
</para>

<para>
  Teste danach die Werte, die von <application>MPlayer</application>
  über die Befehlszeile mittels <option>cropdetect</option> ausgegeben wurden
  und passe das Rechteck nach deinen Bedürfnissen an.
  Der Filter <option>rectangle</option> kann dabei helfen, indem er dir erlaubt,
  das Rechteck interaktiv über dem Film zu positionieren.
  Vergiss nicht, den oben genannten Teilbarkeitsrichtwerten zu folgen, sodass du
  die Chroma-Ebenen nicht verkehrt anordnest.
</para>

<para>
  In bestimmten Fällen könnte Skalieren nicht wünschenswert sein.
  Skalierung in vertikaler Richtung ist mit interlaced Video
  schwierig, und wenn du das Interlacing beibehalten willst, solltest
  du für gewöhnlich das Skalieren bleiben lassen.
  Hast du nicht vor zu skalieren, willst aber nach wie vor Abmessungen
  in einem Vielfachen von 16 verwenden, musst du über den Rand
  hinausschneiden.
  Schneide aber lieber nicht über den Rand hinaus, da schwarze Ränder
  sehr schlecht zu encodieren sind!
</para>

<para>
  Weil MPEG-4 16x16 Macroblöcke nutzt, solltest du dich vergewissern,
  dass jede Abmessung des zu encodierenden Videos ein Vielfaches von
  16 ist oder du verschlechterst andernfalls die Qualität, speziell bei
  niedrigeren Bitraten. Du kannst dies durch Abrunden der Breite und
  Höhe des Ausschnittsrechtecks hinunter auf den nächsten Wert eines
  Vielfachen von 16 erreichen.
  Wie früher bereits erklärt, wirst du beim Abschneiden das y-Offset
  um die Hälfte der Differenz der alten und neuen Höhe erhöhen wollen,
  sodass das daraus resultierende Video aus der Mitte des Frames genommen
  wird. Und stelle wegen der Art, wie ein DVD-Video gesampelt wird, sicher,
  dass das Offset eine gerade Zahl ist. (Verwende in der Tat - als eine
  Regel - nie ungerade Werte für irgendwelche Parameter beim Abschneiden
  oder Skalieren eines Videos) Wenn du dich beim Wegwerfen einiger extra
  Pixel nicht wohl fühlst, ziehst du es stattdessen vor, das Video zu
  skalieren.
  Wir werden uns dies im unten stehenden Beispiel mal ansehen.
  Du kannst den <option>cropdetect</option>-Filter sogar alles oben erwähnte
  für dich erledigen lassen, da dieser einen optionalen Parameter
  <option>round</option> besitzt, der standardmäßig gleich 16 ist.
</para>

<para>
  Pass auch auf &quot;halbschwarze&quot; Pixel an den Kanten auf. Stelle sicher, dass
  du diese ebenfalls mit abschneidest oder du vergeudest dort Bits, wo sie
  doch besser anderswo verwendet werden sollten.
</para>

<para>
  Nachdem nun alles gesagt ist, wirst du möglicherweise bei einem
  Video landen, dessen Pixel nicht ganz 1.85:1 oder 2.35:1, aber ziemlich
  nahe dran sind. Du könntest ein neues Seitenverhältnis manuell berechnen,
  aber <application>MEncoder</application> bietet eine Option für
  <systemitem class="library">libavcodec</systemitem> genannt
  <option>autoaspect</option>, die das für dich erledigt.
  Skaliere dieses Video auf keinen Fall hoch, um die Pixel abzugleichen
  solange du keinen Festplattenplatz verschwenden willst.
  Das Skalieren sollte beim Playback gemacht werden und der Player wird das
  in der AVI gespeicherte Seitenverhältnis zur Bestimmung der besten
  Auflösung verwenden.
  Unglücklicherweise erzwingen nicht alle Player diese Auto-Skalierinformation,
  und deshalb willst du vielleicht trotzdem neu skalieren.
</para>
</sect2>


<sect2 id="menc-feat-dvd-mpeg4-resolution-bitrate">
<title>Auswahl von Auflösung und Bitrate</title>

<para>
  Wenn du nicht vor hast, im Modus mit konstantem Quantisier zu encodieren,
  musst du eine Bitrate auswählen.
  Das Konzept der Bitrate ist denkbar einfach.
  Sie ist die (mittlere) Anzahl Bits, die pro Sekunde zum Speichern des
  Films verbraucht werden.
  Normalerweise wird die Bitrate in Kilobit (1000 Bit) pro Sekunde gemessen.
  Die Größe deines Films auf der Platte ist die Bitrate multipliziert mit der
  Dauer des Films, plus einem kleinen &quot;Overhead&quot; (siehe zum Beispiel in der
  Sektion über
  <link linkend="menc-feat-dvd-mpeg4-muxing-avi-limitations">den AVI-Container</link>).
  Weitere Parameter wie Skalierung, Cropping, usw. werden die Dateigröße
  <emphasis role="bold">nicht</emphasis> ändern, solange du nicht auch
  die Bitrate veränderst!
</para>
<para>
  Die Bitrate skaliert <emphasis role="bold">nicht</emphasis> proportional
  zur Auflösung.
  Dies bedeutet, eine Datei 320x240 mit 200 KBit/Sek wird nicht dieselbe
  Qualität aufweisen wie der gleiche Film bei 640x480 und 800 KBit/Sek!
  Dafür gibt es zwei Gründe:
<orderedlist>
  <listitem><para>
    <emphasis role="bold">Wahrnehmbar</emphasis>: du bemerkst
    MPEG-Artefakte eher, wenn sie größer hochskaliert sind!
    Artefakte erscheinen bei einer Skalierung von Blöcken (8x8).
    Dein Auge wird in 4800 kleinen Blöcken nicht so leicht Fehler sehen
    wie es welche in 1200 großen Blöcken sieht (vorausgesetzt du skalierst
    beide auf Vollbild).
  </para></listitem>
  <listitem><para>
    <emphasis role="bold">Theoretisch</emphasis>: Wenn du ein Bild
    runterskalierst, aber nach wie vor die selbe Größe der (8x8)
    Blöcke zur Frequenzraumtransformation verwendest, bewegst Du
    mehr Daten in die Hochfrequenzbänder.
    Grob gesagt, jedes Pixel enthält mehr des Details als es dies
    zuvor tat.
    Somit enthält dein herunterskaliertes Bild 1/4 der Information
    in räumlichen Richtungen, es könnte immer noch einen hohen Anteil
    Information im Frequenzbereich enthalten (vorausgesetzt dass die
    hohen Frequenzen im originalen 640x480 Bild nicht ausgenutzt wurden).
  </para></listitem>
  </orderedlist>
</para>
<para>
  Vergangene Leitfäden legten nahe, eine Bitrate und Auflösung zu wählen,
  die auf eine &quot;Bits pro Pixel&quot;-Näherung basieren, dies ist jedoch im
  allgemeinen aus oben genannten Gründen nicht gültig.
  Eine bessere Schätzung scheint zu sein, dass Bitraten proportional zur
  Quadratwurzel der Auflösung skalieren, sodass 320x240 und 400 KBit/Sek
  vergleichbar mit 640x480 bei 800 KBit/Sek wären.
  Dies wurde aber nicht mit theoretischer oder empirischer Strenge verifiziert.
  Desweiteren ist es in Anbetracht der Tatsache, dass Filme in Bezug auf Rauschen, Details,
  Bewegungsgrad usw. außerordentlich variieren, zwecklos, allgemeine Empfehlungen
  für die Bits pro Diagonallänge (dem Analog zu Bits pro Pixel
  unter Verwendung der Quadratwurzel) abzugeben.
</para>
<para>
  So weit haben wir nun die Schwierigkeit der Wahl von Bitrate und
  Auflösung diskutiert.
</para>


<sect3 id="menc-feat-dvd-mpeg4-resolution-bitrate-compute">
<title>Berechnen der Auflösung</title>
<para>
  Die folgenden Schritte werden dich in der Berechnung der Auflösung
  deiner Encodierung anleiten, ohne das Video allzusehr zu verzerren,
  indem verschiedene Typen von Informationen über das Quellvideo in
  Betracht gezogen werden.
  Zuerst solltest du die encodierte Auflösung berechnen:
  <systemitem>ARc = (Wc x (ARa / PRdvd )) / Hc</systemitem>
<itemizedlist>
<title>wobwei:</title>
<listitem><para>
  Wc und Hc die Breite und Höhe des zugeschnittenen Videos darstellen
</para></listitem>
<listitem><para>
  ARa das angezeigte Seitenverhältnis ist, das üblicherweise 4/3 oder 16/9 beträgt
</para></listitem>
<listitem><para>
  PRdvd das Pixelverhältnis der DVD ist, welches gleich 1.25=(720/576) für
  PAL-DVDs und 1.5=(720/480) für NTSC-DVDs beträgt
</para></listitem>
</itemizedlist>
</para>

<para>
  Dann kannst du die X- und Y-Auflösung berechnen, gemäß eines gewisse Faktors
  der Kompressionsqualität (CQ):
  <systemitem>ResY = INT(SQRT( 1000*Bitrate/25/ARc/CQ )/16) * 16</systemitem>
  und
  <systemitem>ResX = INT( ResY * ARc / 16) * 16</systemitem>
</para>

<para>
  Okay, aber was ist der CQ?
  Der CQ repräsentiert die Anzahl Bits pro Pixel und pro Frame der Encodierung.
  Grob ausgedrückt, je größer der CQ, desto geringer die Wahrscheinlichkeit,
  Encodierungsartefakte zu sehen.
  Trotz allem, wenn du eine Zielgröße für deinen Film hast (1 oder 2 CDs zum Beispiel),
  gibt es eine begrenzte Gesamtzahl an Bits, die du aufwenden kannst; deswegen ist es
  notwendig, einen guten Kompromiss zwischen Komprimierbarkeit und Qualität zu suchen.
</para>

<para>
  Der CQ hängt von der Bitrate, der Effektivität des Videocodecs und der
  Filmauflösung ab.
  Um den CQ anzuheben, könntest du typischerweise den Film unter der Annahme
  herunterskalieren, dass die Bitrate mit der Funktion der Zielgröße und der
  Länge des Films berechnest, die ja konstant sind.
  Mit MPEG-4 ASP-Codecs wie <systemitem class="library">XviD</systemitem>
  und <systemitem class="library">libavcodec</systemitem>, resultiert ein CQ
  unter 0.18 für gewöhnlich in einem ziemlich blockhaften Bild, weil nicht
  genug Bits zum Codieren der Information jedes Macroblocks vorhanden sind.
  (MPEG4, wie auch viele andere Codecs, gruppiert Pixel nach Blöcken verschiedener
  Pixel, um das Bild zu komprimieren; sind nicht genügend Bits vorhanden,
  werden die Kanten dieser Blöcke sichtbar.)
  Es ist daher weise, einen CQ im Bereich von 0.20 bis 0.22 für einen 1 CD-Rip
  und 0.26-0.28 für einen 2 CD-Rip mit Standard-Encodieroptionen zu nehmen.
  Höherentwickelte Encodieroptionen wie die hier für
  <link linkend="menc-feat-mpeg4-lavc-example-settings"><systemitem class="library">libavcodec</systemitem></link>
  und
  <link linkend="menc-feat-xvid-example-settings"><systemitem class="library">XviD</systemitem></link>
  aufgelisteten sollten es möglich machen, dieselbe Qualität mit einem CQ im Bereich
  von 0.18 bis 0.20 für einen 1 CD-Rip und 0.24 bis 0.26 für einen 2 CD-Rip zu erreichen.
  Mit den MPEG-4 ASP-Codecs wie <systemitem class="library">x264</systemitem>,
  kannst du einen CQ im Bereich von 0.14 bis 0.16 mit Standard-Encodieroptionen
  verwenden, und solltest bis auf 0.10 bis 0.12 mit den
  <link linkend="menc-feat-x264-example-settings">erweiterten Encodieroptionen von
  <systemitem class="library">x264</systemitem></link>
  runter gehen können.
</para>

<para>
  Bitte nimm zur Kenntnis, dass der CQ lediglich eine richtungsweisendes Maß ist,
  da sie vom encodierten Inhalt abhängt. Ein CQ von 0.18 kann für einen
  Bergman-Film recht hübsch aussehen, im Gegensatz zu einem Film wie
  The Matrix, der jede Menge High-Motion-Szenen enthält.
  Auf der anderen Seite ist es nutzlos, den CQ höher als 0.30 zu schrauben,
  da du ohne spürbaren Qualitätsgewinn Bits vergeuden würdest.
  Beachte ebenso, dass wie früher in diesem Handbuch bereits angemerkt,
  niedrig auflösende Videos einen größeren CQ benötigen, um gut auszusehen
  (im Vergleich z.B. zur DVD-Auflösung).
</para>
</sect3>

</sect2>

<sect2 id="menc-feat-dvd-mpeg4-filtering">
<title>Filtern</title>

<para>
  Zu lernen, wie man <application>MEncoder</application>s Videofilter
  verwendet, ist essentiell, um gute Encodierungen zu produzieren.
  Jede Videoverarbeitung wird über Filter ausgeführt -- Ausschneiden,
  Skalieren, Farbanpassung, Rauschentfernung, Scharfzeichnen, Deinterlacing,
  telecine, inverses telecine und Deblocking, um nur ein paar davon aufzuzählen.
  Zusammen mit der gewaltigen Zahl unterstützter Inputformate, ist die Vielfalt der
  in <application>MEncoder</application> verfügbaren Filter eine seiner
  Hauptvorteile im Vergleich zu ähnlichen Programmen.
</para>

<para>
  Filter werden in einer Kette über die Option -vf geladen:

  <screen>-vf filter1=Optionen,filter2=Optionen,...</screen>

  Die meisten Filter nehmen mehrere numerische, kommagetrennte
  Optionen entgegen, jedoch variiert die Syntax der Optionen von
  Filter zu Filter, also lies bitte die Manpage für Details
  zu den Filtern, die du verwenden willst.
</para>

<para>
  Filter wirken auf das Video in der Reihenfolge ein, in der sie geladen werden.
  Zum Beispiel wird folgende Kette:

  <screen>-vf crop=688:464:12:4,scale=640:464</screen>

  zuerst den Bereich 688x464 aus dem Bild schneiden mit der oberen, linken
  Ecke bei (12,4) und danach das Ergebnis auf 640x464 herunter skalieren.
</para>

<para>
  Bestimmte Filter müssen zu oder nahe dem Anfang der Filterkette geladen
  werden, um Vorteile aus den Informationen des Videodecoders zu ziehen,
  die ansonsten durch andere Filter verloren gehen oder ungültig gemacht
  würden.
  Die wichtigsten Beispiele sind <option>pp</option>
  (Nachbearbeitung (postprocessing), nur wenn es Deblock- oder
  Dering-Operationen durchführt), <option>spp</option> (ein weiterer
  Postprozessor zum Entfernen von MPEG-Artefakten), <option>pullup</option>
  (umgekehrtes telecine) und <option>softpulldown</option> (zur Konvertierung
  von soft telecine nach hard telecine).
</para>

<para>
  Im Allgemeinen solltest du den Film so wenig wie möglich Filtern, um
  nahe an der originalen DVD-Quelle zu bleiben. Ausschneiden ist oft
  notwendig (wie oben beschrieben), vermeide aber das Skalieren von Videos.
  Obwohl das Herunterskalieren manchmal vorgezogen wird, um höhere Quantisierer
  zu verwenden, wollen wir beide diese Dinge vermeiden: Erinnere dich daran,
  dass wir von Anfang an beschlossen hatten, einen Kompromiss zwischen
  Bits und Qualität zu schließen.
</para>

<para>
  Passe ebenso kein Gamma, Kontrast, Helligkeit, usw. an. Was auf deinem
  Display gut aussieht, sieht auf anderen eventuell nicht gut aus. Diese
  Anpassungen sollten nur im Playback vorgenommen werden.
</para>

<para>
  Eine Sache, die du vielleicht machen willst, ist, das Video durch einen sehr
  feinen Entrauschfilter (Denoise) zu schicken, wie etwa <option>-vf hqdn3d=2:1:2</option>.
  Nochmals, es geht darum, die Bits einer besseren Verwendung zuzuführen: Warum
  Bits zum Encodieren des Rauschens verschwenden, wenn du dieses Rauschen auch
  während des Playback entfernen kannst?
  Die Parameter für <option>hqdn3d</option> zu erhöhen, wird überdies
  die Komprimierbarkeit erhöhen, erhöhst du jedoch die Werte zu sehr, riskierst Du
  eine Verringerung der Bildsichtbarkeit. Die oben vorgeschlagenen Werte
  (<option>2:1:2</option>) sind ziemlich konservativ; du solltest dich frei
  fühlen, mit höheren Werten herumzuexperimentieren und die Ergebnisse
  selbst zu beobachten.
</para>

</sect2>


<sect2 id="menc-feat-dvd-mpeg4-interlacing">
<title>Interlacing und Telecine</title>

<para>
  Nahezu alle Filme sind bei 24 fps aufgenommen. Weil NTSC 30000/1001 fps entspricht,
  müssen mit diesen 24 fps Videos einige Verarbeitungen durchgeführt werden,
  um sie mit der korrekten NTSC-Framerate laufen zu lassen. Der Prozess wird 3:2
  pulldown genannt, allgemein telecine zugeordnet (weil pulldown des öfteren
  während des telecine-Prozesses angewandt wird), und naiv so beschrieben,
  dass er durch Verlangsamung des Films auf 24000/1001 fps und dem
  Wiederholen jeden vierten Frames arbeitet.
</para>

<para>
  Keine spezielle Verarbeitung ist jedoch bei einem Video für PAL-DVDs
  durchzuführen, das bei 25 fps läuft. (Technisch gesehen kann PAL telecined
  werden, 2:2 pulldown genannt, dies ist jedoch in der Praxis nicht von Bedeutung.)
  Der 24 fps Film wird einfach mit 25 fps abgespielt. Das Resultat ist, dass
  der Film ein wenig schneller abläuft, doch solange du kein Alien bist, wirst
  du möglicherweise keinen Unterschied wahrnehmen.
  Die meisten PAL-DVDs haben pitch-korrigiertes Audio, dadurch hören sie sich
  bei 25 fps abgespielt korrekt an, obwohl der Audiotrack (und infolgedessen der
  gesamte Film) eine 4% kürzere Abspielzeit hat wie NTSC-DVDs.
</para>

<para>
  Weil das Video in einer PAL-DVD nicht verändert wurde, musst du dich nicht
  viel um die Framerate sorgen. Die Quelle ist 25 fps und dein Rip wird 25
  fps haben. Wenn du jedoch einen NTSC-DVD-Film rippst, musst du eventuell
  umgekehrtes telecine anwenden.
</para>

<para>
  Für mit 24 fps aufgenommene Filme ist das Video auf der NTSC-DVD entweder telecined
  30000/1001 oder hat andernfalls progressive 24000/1001 fps und es ist vorgesehen,
  on-the-fly vom DVD-Player telecined zu werden. Auf der anderen Seite sind TV-Serien
  üblicherweise nur interlaced, nicht telecined. Dies ist keine feste Regel: Einige
  TV-Serien sind interlaced (wie etwa Buffy die Vampirjägerin), wogegen andere
  eine Mixtur aus progressive und interlaced sind (so wie Angel oder 24) - wers kennt :).
</para>

<para>
  Es wird strengstens empfohlen, die Sektion über
  <link linkend="menc-feat-telecine">Wie mit telecine und interlacing in NTSC-DVDs umgehen</link>
  durchzulesen, um den Umgang mit den verschiedenen Möglichkeiten zu lernen.
</para>

<para>
  Wenn du aber hauptsächlich nur Filme rippst, gehst du wahrscheinlich entweder
  mit 24 fps progressivem oder telecined Video um, in welchem Falle du
  den Filter <option>pullup</option> mittels <option>-vf pullup,softskip</option>
  verwenden kannst.
</para>

</sect2>

<sect2 id="menc-feat-dvd-mpeg4-encoding-interlaced">
<title>Interlaced Video encodieren</title>

<para>
  Ist der Film, den du encodieren willst, interlaced (NTSC-Video oder
  PAL-Video), wirst du wählen müssen, ob du ihn deinterlacen willst
  oder nicht.
  Während das Deinterlacing deinen Film zwar auf progressiven Scan-Displays
  wie Computermonitoren und Projektoren verwendbar macht, wird dich dies
  doch etwas kosten: Die Feldrate von 50 oder 60000/1001 Feldern pro Sekunde
  wird auf 25 oder 30000/1001 Frames pro Sekunde halbiert und annähernd die
  Hälfte der Informationen in deinem Film geht während Szenen mit
  signifikanter Bewegung verloren.
</para>

<para>
  Deswegen wird empfohlen, wenn du aus Gründen hochqualitativer
  Archivierung encodierst, kein Deinterlacing durchzuführen.
  Du kannst den Film immer noch beim Playback deinterlacen,
  wenn du ihn auf progressiven Scan-Geräten anzeigst. Und zukünftige
  Player werden in der Lage sein, auf volle Feldrate zu
  deinterlacen, mit Interpolation auf 50 oder 60000/1001 komplette
  Frames pro Sekunde aus interlaced Video heraus.
</para>

<para>
  Spezielle Sorgfalt solltest du bei der Arbeit mit interlaced Video walten lassen:
</para>

<orderedlist>
<listitem><para>
  Ausschneidehöhe und y-Offset müssen Vielfache von 4 sein.
</para></listitem>
<listitem><para>
  Jedes vertikale Skalieren muss im interlaced Modus durchgeführt werden.
</para></listitem>
<listitem><para>
  Nachbearbeitungs- (postprocessing) und Rauschunterdrückungsfilter (denoising)
  funktionieren eventuell nicht wie erwartet, wenn du nicht speziell darauf achtest,
  dass sie zu einem Zeitpunkt nur ein Feld verarbeiten, und sie können das Video
  kaputt machen, wenn sie inkorrekt angewendet werden.
</para></listitem>
</orderedlist>

<para>
  Mit diesen Dingen im Kopf, hier das erste Beispiel:
</para>
<screen>
  mencoder <replaceable>capture.avi</replaceable> -mc 0 -oac lavc -ovc lavc -lavcopts \
  vcodec=mpeg2video:vbitrate=6000:ilme:ildct:acodec=mp2:abitrate=224
</screen>
<para>
  Beachte die Optionen <option>ilme</option> und <option>ildct</option>.
</para>
</sect2>


<sect2 id="menc-feat-dvd-mpeg4-av-sync">
<title>Anmerkungen zur Audio-/Videosynchronisation</title>
<para>
  <application>MEncoder</application>s Algorithmen der Audio-/Videosynchronisation
  wurden mit der Intention entwickelt, Dateien mit kaputter Sychronisation wieder herzustellen.
  In einigen Fällen können unnötiges Überspringen und Duplizieren
  von Frames und möglicherweise leichte A/V-Desynchronisation verursachen, auch wenn sie
  mit dem richtigen Input verwendet werden
  (gewiss, Probleme mit A/V-Synchronisation treffen nur zu, wenn du den Audiotrack während
  der Transcodierung des Videos verarbeitest oder kopierst, wozu auch nachhaltig
  ermutigt wird).
  Hierfür müsstest du mit der Option <option>-mc 0</option> in die
  Grundeinstellung der A/V-Synchronisation wechseln oder diese in deine
  <systemitem>~/.mplayer/mencoder</systemitem> Konfigurationsdatei eintragen,
  solange du ausschließlich mit guten Quellen arbeitest (DVD, TV-Capture,
  hochqualitativen MPEG-4-Rips usw.) und mit nicht-kaputten ASF/RM/MOV-Dateien.
</para>
<para>
  Wenn du dich überdies gegen merkwürdige Frameübersprünge und -duplikationen
  absichern willst, kannst du beides verwenden, <option>-mc 0</option>
  und <option>-noskip</option>.
  Dies verhindert <emphasis>jede</emphasis> A/V-Synchronisation und kopiert die Frames
  eins-zu-eins, somit kannst du sie nicht verwenden, falls du irgendwelche Filter
  verwendest, die unvorhersagbar Frames hinzufügen oder streichen oder falls
  deine Input-Datei eine variable Framerate besitzt!
  Deshalb wird eine allgemeine Anwendung von <option>-noskip</option> nicht empfohlen.
</para>
<para>
  Die von <application>MEncoder</application> unterstützte sogenannte
  &quot;3-pass&quot; Audioencodierung soll laut Berichten A/V-Desynchronisation
  verursachen.
  Dies geschieht definitiv dann, wenn sie in Verbindung mit bestimmten Filtern
  verwendet wird, daher wird <emphasis>nicht</emphasis> empfohlen, den
  3-pass-Audio-Modus anzuwenden.
  Dieses Feature ist nur aus Kompatibilitätsgründen übrig geblieben und für
  erfahrene Benutzer, die wissen, wann es sicher anzuwenden ist und wann nicht.
  Wenn du zuvor noch nie etwas vom 3-pass-Modus gehört hast, vergiss, dass wir es je
  erwähnt haben!
</para>
<para>
  Es gab auch Berichte über A/V-Desynchronisation, wenn
  mit <application>MEncoder</application> von stdin encodiert wurde.
  Lass das bleiben! Verwende immer eine Datei oder ein CD/DVD/usw-Laufwerk
  als Input.
</para>
</sect2>

<sect2 id="menc-feat-dvd-mpeg4-codec">
<title>Auswahl des Videocodecs</title>

<para>
  Welcher Videocodec die beste Wahl ist, hängt von mehreren Faktoren
  wie Größe, Qualität, Streambarkeit, Brauchbarkeit und Popularität, manche
  davon weitgehend vom persönlichen Geschmack und technischen
  Randbedingungen ab.
</para>
<itemizedlist>
  <listitem><para>
  <emphasis role="bold">Kompressionseffizienz</emphasis>:
  Es ist leicht zu verstehen, dass die meisten Codecs der neueren Generation
  dafür gemacht wurden, Qualität und Komprimierung zu verbessern.
  Deshalb behauptet der Autor dieses Handbuches und viele andere Leute, dass
  du nichts verkehrt machen kannst,
  <footnote id='fn-menc-feat-dvd-mpeg4-codec-cpu'>
  <para>Sei trotzdem vorsichtig: MPEG-4 AVC-Videos in DVD-Auflösung zu
  decodieren erfordert einen schnellen Rechner (z.B. einen Pentium 4
  über 1.5Ghz oder einen Pentium M über 1Ghz).
  </para></footnote>
  wenn du MPEG-4 AVC-Codecs wie
  <systemitem class="library">x264</systemitem> anstatt MPEG-4 ASP-Codecs
  wie <systemitem class="library">libavcodec</systemitem> MPEG-4 oder
  <systemitem class="library">XviD</systemitem> wählst.
  (Zukunftsorientierte Codec-Entwickler interessiert eventuell Michael
  Niedermayers Meinung
  &quot;<ulink url="http://guru.multimedia.cx/?p=10">why MPEG4-ASP sucks</ulink>&quot;
  zu lesen.)
  Ebenso solltest du mit MPEG-4 ASP eine bessere Qualität erhalten als mit
  MPEG-2-Codecs.
  </para>
  <para>
  Allerdings können neuere Codecs, die noch stark in der Entwicklung stecken,
  unter unentdeckten Bugs leiden, die die Encodierung ruinieren können.
  Dies nimmt man schlicht in Kauf, wenn man "bleeding edge"-Technologie
  verwendet.
  </para>
  <para>
  Außerdem erfordert der Umgang mit einem neuen Codec und sich mit dessen Optionen
  vertraut zu machen eine Zeit, bis du weißt, was alles anzupassen
  ist, um die erhoffte Bildqualität zu erreichen.
  </para></listitem>

  <listitem><para>
  <emphasis role="bold">Hardware-Kompatibilität</emphasis>:
  Gewöhnlich dauert es bei neuen standalone Video-Playern lange, bis der
  Support für die neuesten Videocodecs eingebunden ist.
  Als ein Ergebnis unterstützen die meisten nur MPEG-1 (wie VCD, XVCD
  und KVCD), MPEG-2 (wie DVD, SVCD und KVCD) und MPEG-4 ASP (wie DivX,
  LMP4 von <systemitem class="library">libavcodec</systemitem> und
  <systemitem class="library">XviD</systemitem>)
 (Vorsicht: Im Allgemeinen werden nicht alle MPEG-4 ASP-Features unterstützt).
  Sieh bitte in den technischen Spezifikationen deines Players nach (falls
  welche vorhanden sind) oder google nach mehr Informationen.
  </para></listitem>

  <listitem><para>
  <emphasis role="bold">Beste Qualität pro Encodierzeit</emphasis>:
  Codecs, die es schon einige Zeit gibt (wie
  <systemitem class="library">libavcodec</systemitem> MPEG-4 und
  <systemitem class="library">XviD</systemitem>), sind gewöhnlich heftig
  mit allen möglichen intelligenten Algorithmen und SIMD Assembly-Code optimiert.
  Das sind sie deshalb, weil sie darauf abzielen, das beste Verhältnis von Qualität
  pro Encodierzeit zu liefern.
  Jedoch haben sie oft einige sehr fortschrittliche Optionen, die,
  wenn aktiviert, das Encodieren bei marginalem Gewinn wirklich langsam
  machen.
  </para>
  <para>
  Wenn du es auf die Wahnsinnsgeschwindigkeit abzielst, solltest du
  in der Nähe der Standardeinstellungen des Videocodecs bleiben
  (obwohl du ruhig weitere Optionen ausprobieren solltest, die in
  anderen Sektionen dieses Handbuchs angesprochen werden).
  </para>
  <para>
  Vielleicht überlegst du auch, einen Codec auszuwählen, der mit
  Multi-Threading klarkommt, was nur für Benutzer von Rechnern
  mit mehreren CPUs von Nutzen ist.
  <systemitem class="library">libavcodec</systemitem> MPEG-4 erlaubt
  dies zwar, aber die Geschwindigkeitsgewinne sind begrenzt und es gibt
  einen leicht negativen Effekt in Bezug auf die Bildqualität.
  Die Multi-Thread-Encodierung von <systemitem class="library">XviD</systemitem>,
  durch die Option <option>threads</option> aktiviert, kann zum Ankurbeln
  der Encodiergeschwindigkeit - um in typischen Fällen etwa 40-60% -
  bei wenn überhaupt geringer Bildverschlechterung verwendet werden.
  <systemitem class="library">x264</systemitem> erlaubt ebenfalls
  Multi-Thread-Encodierung, was im Moment das Encodieren um 15-30% beschleunigt
  (abhängig von den Encodier-Einstellungen) bei gleichzeitiger Verringerung des
  PSNR um etwa 0.05dB.
  </para></listitem>

  <listitem><para>
  <emphasis role="bold">Persönlicher Geschmack</emphasis>:
  Hier beginnt die Angelegenheit oft irrational zu werden: Aus den selben
  Gründen, aus denen manche über Jahre an DivX 3 hängen, während neuere
  Codecs bereits Wunder wirken, ziehen einige Leute
  <systemitem class="library">XviD</systemitem>
  oder <systemitem class="library">libavcodec</systemitem> MPEG-4 dem
  <systemitem class="library">x264</systemitem> vor.
  </para>
  <para>
  Du solltest dir dein eigenes Urteil bilden; lass dich nicht von Leuten
  vollquasseln, die auf den einen Codec schwören.
  Nimm ein paar Beispiel-Clips von Originalquellen und vergleiche die
  verschiedenen Encodier-Optionen und Codecs, um den einen zu finden, mit
  dem du am besten klarkommst.
  Der beste Codec ist der, den du beherrschst und der in deinen Augen
  auf deinem Display am besten aussieht.
  <footnote id='fn-menc-feat-dvd-mpeg4-codec-playback'>
  <para>Dieselbe Encodierung kann auf dem Monitor eines anderen vollkommen
  anders aussehen oder wenn sie von einem anderen Decoder abgespielt wird,
  also mach deine Encodierungen zukunftssicher indem du sie unter verschiedenen
  Setups ablaufen lässt.</para></footnote>!
  </para></listitem>
</itemizedlist>
<para>
  Sieh dazu bitte in der Sektion
  <link linkend="menc-feat-selecting-codec">Auswahl der Codecs und Containerformate</link>
  nach der Liste der unterstützten Codecs.
</para>
</sect2>

<sect2 id="menc-feat-dvd-mpeg4-audio">
<title>Audio</title>

<para>
  Audio ist ein leichter zu lösendes Problem: Wenn du Wert auf Qualität legst,
  lass es einfach so wie es ist.
  Gerade AC3 5.1 Streams sind meist 448Kbit/s und jedes Bit wert.
  Möglicherweise gerätst du in Versuchung, Audio in hochwertiges Vorbis
  umzuwandeln, aber nur weil du heute keinen A/V-Receiver für AC3-pass-through
  besitzt, bedeutet dies nicht, dass du nicht morgen doch einen hast.
  Halte deine DVD-Rips zukunftssicher, indem du den AC3-Stream beibehältst.
  Du behältst den AC3-Stream entweder, indem du ihn
  <link linkend="menc-feat-mpeg4">während der Encodierung</link> direkt in den
  Video-Stream kopierst.
  Du kannst den AC3-Stream aber auch extrahieren, um ihn in Container wie NUT
  oder Matroska zu muxen.
  <screen>mplayer <replaceable>source_file.vob</replaceable> -aid 129 -dumpaudio -dumpfile <replaceable>sound.ac3</replaceable></screen>
  dumpt Audiotrack Nummer 129 aus der Datei <replaceable>source_file.vob</replaceable>
  (NB: DVD-VOB-Dateien verwenden gewöhnlich andere Audionummerierungen,
  was bedeutet, dass der VOB-Audiotrack 129 der 2-te Audiotrack der Datei ist)
  in die Datei <replaceable>sound.ac3</replaceable>.
</para>

<para>
  Aber manchmal hast du wirklich keine andere Wahl als den Sound weiter zu
  komprimieren, sodass mehr Bits fürs Video aufgewendet werden können.
  Die meisten Leute entscheiden sich für eine Audiokomprimierung mit MP3- oder
  Vorbis-Audiocodecs.
  Wobei letzterer ein sehr platzsparender Codec ist, MP3 wird von Hardware-Playern
  besser unterstützt, wobei sich dieser Trend auch ändert.
</para>

<para>
  Verwende <emphasis>nicht</emphasis> <option>-nosound</option> beim Encodieren
  einer Datei, die Audio enhält, sogar wenn du Audio später separat
  encodierst und muxt.
  Zwar kann es im Idealfall manchmal funktionieren, wenn du <option>-nosound</option>
  verwendest, wahrscheinlich um einige Probleme in deinen
  Encodier-Befehlszeileneinstellungen zu verbergen.
  In anderen Worten, einen Soundtrack während dem Encodieren zu haben, stellt sicher,
  vorausgesetzt du siehst keine Meldungen wie
  <quote>Too many audio packets in the buffer</quote>, dass du in der Lage sein
  wirst, eine korrekte Synchronisation zu erhalten.
</para>

<para>
  Du brauchst <application>MEncoder</application> zur Verarbeitung des Sounds.
  Du kannst zum Beispiel den originalen Soundtrack während dem Encodieren mit
  <option>-oac copy</option> kopieren oder ihn mittels
  <option>-oac pcm -channels 1 -srate 4000</option> in eine &quot;leichte&quot;
  4 kHz Mono WAV-PCM konvertieren.
  Anderenfalls wird er - in einigen Fällen - eine Videodatei erzeugen, die
  nicht mit Audio synchron läuft.
  So was kommt vor, wenn die Anzahl der Videoframes in der Quelldatei nicht
  mit der Gesamtlänge der Audioframes zusammenpasst oder immer dann, wenn
  Unstetigkeiten/Splices vorhanden sind, wo Audioframes oder extra Audioframes
  fehlen.
  Der korrekte Weg, mit dieser Art Problem umzugehen, ist Stille (silence)
  einzufügen oder Audio an diesen Punkten wegzuschneiden.
  Seis drum, <application>MPlayer</application> kann das nicht, also wenn du
  AC3-Audio demuxt und es in einer separaten Anwendung encodierst (oder
  es mit <application>MPlayer</application> in eine PCM dumpst), die Splices
  bleiben inkorrekt und der einzige Weg sie zu korrigieren ist, Videoframes
  an diesem Splice zu streichen bzw. zu duplizieren.
  Solange <application>MEncoder</application> Audio beim Encodieren des
  Videos sieht, kann er dieses Streichen/Duplizieren erledigen, was
  gewöhnlich OK ist, da es bei voller Schwärze/Szenenwechsel stattfindet,
  aber wenn <application>MEncoder</application> Audio nicht erkennen kann,
  wird er einfach alle Frames so wie sie ankommen verarbeiten und sie werden
  einfach nicht zum endgültigen Audiostream passen, wenn du beispielsweise
  deinen Audio- und Videotrack in eine Matroska-Datei mergst.
</para>

<para>
  Zuallererst wirst du den DVD-Sound in eine WAV-datei konvertieren müssen, die
  der Audiocodec als Input nutzen kann.
  Zum Beispiel:
  <screen>mplayer <replaceable>source_file.vob</replaceable> -ao pcm:file=<replaceable>destination_sound.wav</replaceable> -vc dummy -aid 1 -vo null</screen>
  wird den zweiten Audiotrack aus der Datei <replaceable>source_file.vob</replaceable>
  in die Datei <replaceable>destination_sound.wav</replaceable> dumpen.
  Vielleicht willst du den Sound vor dem Encodieren normalisieren, da
  DVD-Audiotracks gemeinhin bei niedriger Lautstärke aufgenommen sind.
  Du kannst beispielsweise das Tool <application>normalize</application> verwenden,
  das in den meisten Distributionen zur Verfügung steht.
  Wenn du Windows nutzt, kann ein Tool wie <application>BeSweet</application>
  denselben Job erledigen.
  Du wirst entweder nach Vorbis oder MP3 komprimieren.
  Zum Beispiel:
  <screen>oggenc -q1 <replaceable>destination_sound.wav</replaceable></screen>
  wird <replaceable>destination_sound.wav</replaceable> mit
  der Encodierqualität 1 encodieren, was annähernd 80Kb/s ergibt und
  die Minimalqualität darstellt, mit der du encodieren solltest, wenn du
  Wert auf Qualität legst.
  Nimm bitte zur Kenntnis, dass MEncoder aktuell keine Vorbis-Audiotracks
  in die Output-Datei muxen kann, da er nur AVI- und MPEG-Container als
  Output unterstützt, wobei es beim Audio-/Videoplayback zu
  Synchronisationproblemen mit einigen Playern führen wird, wenn die AVI-Datei
  VBR-Audiostreams wie z.B. Vorbis enthält.
  Keine Bange, dieses Dokument wird dir zeigen, wie du das mit
  Third-Party-Programmen hinbekommst.
</para>

</sect2>


<sect2 id="menc-feat-dvd-mpeg4-muxing">
<title>Muxen</title>
<para>
  Nun da du dein Video encodiert hast, wirst du es höchstwahrscheinlich
  mit einem oder mehr Audiotracks in einen Movie-Container wie etwa
  AVI, MPEG, Matroska oder NUT muxen.
  <application>MEncoder</application> ist aktuell nur in der Lage,
  Audio und Video nativ in MPEG- und AVI-Containerformate auszugeben.
  Zum Beispiel:
  <screen>mencoder -oac copy -ovc copy -o <replaceable>output_movie.avi</replaceable> -audiofile <replaceable>input_audio.mp2</replaceable> <replaceable>input_video.avi</replaceable></screen>
  würde die Video-Datei <replaceable>input_video.avi</replaceable>
  und die Audio-Datei <replaceable>input_audio.mp2</replaceable>
  in die AVI-Datei <replaceable>output_movie.avi</replaceable> mergen.
  Dieser Befehl funktioniert mit MPEG-1 Layer I, II und III Audio (eher
  bekannt als MP3), WAV und auch mit ein paar weiteren Audioformaten.
</para>

<para>
  MEncoder zeichnet sich aus durch experimentellen Support für
  <systemitem class="library">libavformat</systemitem>, das eine
  Programmbibliothek des FFmpeg-Projekts ist, welches das Muxen und
  Demuxen einer Vielzahl von Containern unterstützt.
  Zum Beispiel:
  <screen>mencoder -oac copy -ovc copy  -o <replaceable>output_movie.asf</replaceable> -audiofile <replaceable>input_audio.mp2</replaceable> <replaceable>input_video.avi</replaceable> -of lavf -lavfopts format=asf</screen>
  wird das selbe machen, wie das obere Beispiel, außer dass der
  Output-Container ASF sein wird.
  Bitte nimm zur Kenntnis, dass dieser Support hochexperimentell ist
  (aber von Tag zu Tag besser wird) und nur funktionieren wird, wenn du
  <application>MPlayer</application> mit aktiviertem Support für
  <systemitem class="library">libavformat</systemitem> kompiliert
  hast (was meint, dass eine Pre-Packaged Binary Version in den meisten
  Fällen nicht funktionieren wird).
</para>


<sect3 id="menc-feat-dvd-mpeg4-muxing-filter-issues">
<title>Verbessern der Mux- und A/V-Synchronisationszuverlässigkeit</title>
<para>
  Es kann vorkommen, dass du ernsthafte A/V-Synchronisationsprobleme hast während
  du versuchst, deine Video- und einige Audiotracks zu muxen, wobei es nichts
  ändert, wenn du das Audiodelay anpasst, du bekommst nie eine korrekte
  Synchronisation zu Stande.
  Dies kann vorkommen, wenn du manche Videofilter verwendest, die einige Frames
  weglassen oder duplizieren, wie etwa die inverse telecine-Filter.
  ich kann dich nur dazu ermutigen, den <option>harddup</option>-Videofilter
  ans Ende der Filterkette anzuhängen, um solcherlei Problemen aus dem Weg
  zu gehen.
</para>

<para>
  Ohne <option>harddup</option> verlässt sich <application>MEncoder</application>,
  wenn er einen Frame duplizieren will, darauf, dass der Muxer eine Marke auf den
  Container setzt, sodass der letzte Frame nochmals angezeigt wird, um
  während des Schreibens des aktuellen Frames synchron zu bleiben.
  Mit <option>harddup</option> wird <application>MEncoder</application>
  statt dessen einfach den zuletzt angezeigten Frame nochmal in die Filterkette
  einschieben.
  Dies bedeutet, dass der Encoder <emphasis>exakt</emphasis> denselben Frame
  zweimal entgegen nimmt und komprimiert.
  Dies ergibt eine etwas größere Datei, verursacht jedoch keine Probleme
  beim Demuxen oder Remuxen in ein anderes Containerformat.
</para>

<para>
  Du kommst auch nicht um den Einsatz von <option>harddup</option> im
  Zusammenhang mit Containerformaten herum, die nicht allzu fest mit
  <application>MEncoder</application> verlinkt sind, wie etwa diejenigen,
  welche von <systemitem class="library">libavformat</systemitem> unterstützt
  werden, der keine Frameduplikation auf Container-Level unterstützt.
</para>
</sect3>


<sect3 id="menc-feat-dvd-mpeg4-muxing-avi-limitations">
<title>Limitierungen des AVI-Containers</title>
<para>
  Obwohl es das am breitesten unterstützte Containerformat nach MPEG-1 ist,
  besitzt AVI auch einige gravierende Nachteile.
  Der vielleicht offensichtlichste ist der Overhead.
  Für jeden Block der AVI-Datei werden 24 Byte auf Header und Indizes
  verschwendet.
  Dies heißt übersetzt etwas mehr als 5 MB pro Stunde oder 1-2.5%
  Overhead für einen 700 MB Film. Das sieht nicht nach viel aus, könnte aber
  die Differenz zwischen einem Video mit 700 KBit/Sek oder 714 KBit/Sek
  bedeuten, und jedes bisschen mehr an Qualität zählt.
</para>

<para>
  Zu dieser schockierenden Ineffizienz kommen bei AVI noch folgende
  wesentlichen Einschränkungen:
</para>

<orderedlist>
<listitem>
<para>
  Nur Inhalt mit festen fps kann gespeichert werden. Dies ist insbesondere
  dann einschränkend, wenn das Originalmaterial, das du encodieren willst,
  gemischter Inhalt ist, zum Beispiel ein Mix aus NTSC-Video und
  Filmmaterial.
  Eigentlich gibt es Hacks, die es ermöglichen, Inhalt mit gemischter
  Framerate in einer AVI unterzubringen, diese vergrößern jedoch den
  (ohnehin großen) Overhead fünffach oder mehr und sind somit ungeeignet.
</para>
</listitem>
<listitem>
<para>
  Audio in AVI-Dateien muss entweder konstante Bitrate (CBR) oder
  konstante Framegröße haben (also alle Frames decodieren zur selben Anzahl
  Samples).
  Unglücklicherweise erfüllt Vorbis, der effektivste Codec, keine dieser
  Anforderungen.
  Deshalb wirst du einen weniger effizienten Codec wie MP3 oder AC3 verwenden
  müssen, wenn du planst, einen Film in AVI zu speichern.
</para>
</listitem>
</orderedlist>

<para>
  Nachdem ich nun all dies erzählt habe, muss ich anmerken, momentan
  unterstützt <application>MEncoder</application> keinen Output mit
  variablen fps oder Vorbis-Encodierung.
  Deswegen magst du dies nicht als Einschränkung ansehen, falls
  <application>MEncoder</application> das einzige Tool ist, das du
  nutzt, um deine Ecodierungen zu produzieren.
  Es ist dennoch möglich, <application>MEncoder</application> nur zur
  Videoencodierung zu verwenden und danach externe Tools, um Audio
  zu encodieren und in ein anderes Containerformat zu muxen.
</para>
</sect3>

<sect3 id="menc-feat-dvd-mpeg4-muxing-matroska">
<title>Muxen in den Matroska-Container</title>
<para>
  Matroska ist ein freies, offenes Containerformat, das darauf abzielt,
  eine Menge erweiterter Features bereitzustellen, mit denen ältere Container
  wie AVI nicht umgehen können.
  Zum Beispiel unterstützt Matroska Audioinhalt mit variabler Bitrate (VBR),
  variable Frameraten (VFR), Kapitel, Dateianhänge,
  Fehlererkennung Error Detection Code (EDC) und modern A/V-Codecs wie &quot;Advanced Audio
  Coding&quot; (AAC), &quot;Vorbis&quot; oder &quot;MPEG-4 AVC&quot; (H.264), so gut wie nichts
  womit AVI etwas anfangen kann.
</para>

<para>
  Die zum Erzeugen von Matroska-Dateien erforderlichen Tools werden
  zusammen <application>mkvtoolnix</application> genannt und stehen
  für die meisten Unix-Plattformen wie auch <application>Windows</application>
  zur Verfügung.
  Weil Matroska ein offener Standard ist, findest du vielleicht andere
  Tools, die sich besser für dich eignen, aber da mkvtoolnix das am meisten
  Verbreitete ist und von Matroska selbst unterstützt wird, werden wir nur
  dessen Anwendung einbeziehen.
</para>

<para>
  Möglicherweise der einfachste Weg, mit Matroska anzufangen, ist
  <application>MMG</application> zu verwenden, das grafische Frontend,
  das mit <application>mkvtoolnix</application> daherkommt, und dem
  <ulink url="http://www.bunkus.org/videotools/mkvtoolnix/doc/mkvmerge-gui.html">guide to mkvmerge GUI (mmg)</ulink>
  zu folgen.
</para>

<para>
  Du kannst Audio und Video-Dateien auch per Befehlszeile muxen:
  <screen>mkvmerge -o <replaceable>output.mkv</replaceable> <replaceable>input_video.avi</replaceable> <replaceable>input_audio1.mp3</replaceable> <replaceable>input_audio2.ac3</replaceable></screen>
  würde die Video-Datei <replaceable>input_video.avi</replaceable>
  und die zwei Audio-Dateien <replaceable>input_audio1.mp3</replaceable>
  und <replaceable>input_audio2.ac3</replaceable> in die Matroska-Datei
  <replaceable>output.mkv</replaceable> mergen.
  Matroska, wie zuvor beschrieben, ist in der Lage, noch viel mehr als
  das zu tun, wie etwa multiple Audiotracks (inklusive Feintuning der
  Audio-/Videosynchronisation), Kapitel, Untertitel, Splitting, usw...
  Sieh bitte in den Dokumentationen dieser Anwendungen nach mehr Details.
</para>

</sect3>

</sect2>

</sect1>

<sect1 id="menc-feat-telecine">
<title>Wie mit telecine und interlacing in NTSC-DVDs umgehen</title>

<sect2 id="menc-feat-telecine-intro">
<title>Einführung</title>
<formalpara>
<title>Was ist telecine?</title>
<para>
  Ich schlage vor, du besuchst diese Seite, wenn du nicht viel von dem
  verstehst, was in diesem Dokument beschrieben wird:
  <ulink url="http://www.divx.com/support/guides/guide.php?gid=10">http://www.divx.com/support/guides/guide.php?gid=10</ulink>
  Diese URL führt zu einer verständlichen und einigermaßen umfassenden
  Beschreibung dessen, was telecine ist.
</para></formalpara>

<formalpara>
<title>Eine Anmerkung zu Zahlen</title>
<para>
  Viele Dokumente, einschließlich des oben verlinkten Handbuchs, beziehen
  sich auf den Wert Felder pro Sekunde von NTSC-Video als 59.94 und den
  korrespondierenden Frames pro Sekunde als 29.97 (für telecined und
  interlaced) und 23.976 (für progressiv). Zur Vereinfachung runden
  manche dieser Dokumente sogar auf 60, 30 und 24 auf.
</para></formalpara>

<para>
  Streng genommen sind alle diese Zahlen Näherungswerte. Das schwarz/weiße
  NTSC-Video war exakt 60 Felder pro Sekunde, später wurde jedoch 60000/1001
  gewählt, um die Farbdaten anzupassen, solange man gleichzeitig
  zu Schwarz/weiß-Fernsehen kompatibel blieb. Digitales NTSC-Video
  (so wie auf einer DVD) hat ebenfalls 60000/1001 Felder pro Sekunde. Hieraus
  wird interlaced und telecined Video als 30000/1001 Frames pro Sekunde
  enthaltend abgeleitet; progressive Video hat 24000/1001 Frames pro Sekunde.
</para>

<para>
  Ältere Versionen der <application>MEncoder</application>-Dokumentation
  und viele archivierten Posts in Mailing-Listen beziehen sich auf 59.94,
  29.97 und 23.976.
  Alle <application>MEncoder</application>-Dokumentationen wurden insofern
  aktualisiert, dass sie fraktionale Werte verwenden, und du solltest dies
  auch tun.
</para>

<para>
  <option>-ofps 23.976</option> ist inkorrekt.
  <option>-ofps 24000/1001</option> sollte statt dessen benutzt werden.
</para>

<formalpara>
<title>Wie telecine angewandt wird</title>
<para>
  Jedes Video, das zur Anzeige auf einem NTSC-Fernseh-Set vorgesehen ist,
  muss 60000/1001 Felder pro Sekunde haben. Für TV-Filme und Shows
  hergestellt sind sie häufig direkt mit 60000/1001 Feldern pro Sekunde
  aufgenommen, die Mehrheit der Kinofilme jedoch mit 24 oder 24000/1001
  Frames pro Sekunde. Wenn cinematische Movie-DVDs gemastert werden,
  wird das Video danach fürs Fernsehen mittels eines telecine genannten
  Prozesses konvertiert.
</para></formalpara>

<para>
  Auf einer DVD wird das Video eigentlich nie als 60000/1001 Felder
  pro Sekunde abgelegt. Für ein Video, das ursprünglich 60000/1001 war,
  wird jedes Feldpaar zu einem Frame kombiniert, was dann 30000/1001
  Frames pro Sekunde ergibt. Hardware-DVD-Player lesen dann ein im
  Videostream eingebettetes Kennzeichen aus, um zu bestimmen, ob die gerade
  oder ungerade nummerierten Zeilen das erste Feld formen sollen.
</para>

<para>
  Üblicherweise bleibt ein Inhalt mit 24000/1001 Frames pro Sekunde
  so wie er ist, wenn er für eine DVD encodiert wird, und der DVD-Player
  muss das Telecining on-the-fly bewerkstelligen. Manchmal jedoch wird das
  Video telecined <emphasis>bevor</emphasis> es auf der DVD gespeichert wird;
  selbst wenn es ursprünglich 24000/1001 Frames pro Sekunde war, wird es
  60000/1001 Felder pro Sekunde. Wenn es auf der DVD gespeichert wird,
  werden Feldpaare zu 30000/1001 Frames pro Sekunde kombiniert.
</para>

<para>
  Wenn man das aus 60000/10001 Feldern pro Sekunde geformten Einzelframes
  erzeugte Video betrachtet, ist telecined oder anderenfalls Interlacing
  klar sichtbar woimmer Bewegung auftritt, da ein Feld (sagen wir, die
  geradzahlig nummerierten Zeilen) einen Moment zur Zeit 1/(60000/1001) Sekunden
  später als das andere repräsentiert. Spielt man ein interlaced Video auf
  einem Computer ab, sehen beide hässlich aus, weil der Monitor eine höhere
  Auflösung besitzt und weil das Video Frame für Frame anstatt Feld für Feld
  angezeigt wird.
</para>

<itemizedlist>
<title>Anmerkungen</title>
<listitem><para>
  Dieser Abschnitt gilt nur für NTSC-DVDs und nicht für PAL.
  </para></listitem>
<listitem><para>
  Die <application>MEncoder</application>-Beispielzeilen überall im
  Dokument sind <emphasis role="bold">nicht</emphasis> zum
  eigentlichen Gebrauch vorgesehen. Sie sind schlicht das bloße Minimum,
  das zum Encodieren der betreffenden Videokategorie benötigt wird.
  Wie mache ich gute DVD-Rips oder wie feintune ich
  <systemitem class="library">libavcodec</systemitem> auf maximale
  Qualität gehören nicht zum Umfang dieses Dokuments.
  </para></listitem>
<listitem><para>
  Es gibt ein paar Fußnoten speziell für dieses Handbuch, die so ähnlich
  verlinkt sind:
  <link linkend="menc-feat-telecine-footnotes">[1]</link>
  </para></listitem>
</itemizedlist>
</sect2>

<sect2 id="menc-feat-telecine-ident">
<title>Wie kann man sagen, welchen Typ Video man hat</title>

<sect3 id="menc-feat-telecine-ident-progressive">
<title>Progressiv</title>
<para>
  Progressive Video wurde ursprünglich mit 24000/1001 fps gefilmt und
  ohne Änderung auf der DVD abgespeichert.
</para>

<para>
  Wenn du eine progressive DVD in <application>MPlayer</application> abspielst,
  wird <application>MPlayer</application> folgende Zeile ausgeben, sobald
  das Abspielen des Films beginnt:

  <screen> demux_mpg: 24000/1001 fps progressive NTSC content detected, switching framerate.</screen>

  Von diesem Punkt an vorwärts sollte demux_mpg nie erzählen, es finde
  &quot;30000/1001 fps NTSC content.&quot;
</para>

<para>
  Wenn du progressives Video ankuckst, solltest du nie irgendein
  Interlacing sehen. Sei trotzdem vorsichtig, weil manchmal ein winziges
  bisschen telecine dort hineingemischt wurde, wo du es nicht erwartest.
  Ich bin TV-Serien-DVDs begegnet, die eine Sekunde telecine bei jedem
  Szenenwechsel haben oder an extrem zufälligen Stellen. Ich hatte mir einmal
  eine DVD angesehen, die eine progressive erste Hälfte besaß, und die
  zweite Hälfte war telecined. Willst du<emphasis>wirklich</emphasis>
  gründlich sein, kannst du den kompletten Film scannen:

  <screen>mplayer dvd://1 -nosound -vo null -benchmark</screen>

  Das Verwenden von <option>-benchmark</option> veranlasst
  <application>MPlayer</application>, den Film so schnell er es nur kann
  abzuspielen; dies dauert je nach Hardware trotzdem noch eine
  Weile. Jedesmal wenn demux_mpg einen Frameratenwechsel meldet, wird dir
  die Zeile unmittelbar darüber die Zeit zeigen, bei welcher der Wechsel
  auftrat.
</para>

<para>
  Manchmal wird progressive Video auf DVDs
  &quot;soft telecine&quot; zugeordnet, weil es dazu vorgesehen ist,
  vom DVD-Player telecined zu werden.
</para>
</sect3>

<sect3 id="menc-feat-telecine-ident-telecined">
<title>Telecined</title>
<para>
  Telecined Video war ursprünglich mit 24000/1001 aufgenommen, wurde aber
  telecined, <emphasis>bevor</emphasis> es auf die DVD geschrieben wurde.
</para>

<para>
  <application>MPlayer</application> meldet keine (nie)
  Frameratenwechsel, wenn er telecined Video abspielt.
</para>

<para>
  Beim Betrachten eines telecined Videos wirst du Interlacing-Artefakte
  sehen, die zu &quot;blinken&quot; scheinen: sie erscheinen wiederholt
  und verschwinden wieder.
  Du kannst dir das so genauer hinschauen
  <orderedlist>
  <listitem>
    <screen>mplayer dvd://1</screen>
    </listitem>
  <listitem><para>
    Suche einen Teil mit Bewegung.
    </para></listitem>
  <listitem><para>
    Benutze die Taste <keycap>.</keycap>, um jeweils einen Frame vorwärts zu rücken.
    </para></listitem>
  <listitem><para>
    Schau auf das Muster der interlaced und progressive aussehenden
    Frames. Ist das Muster, das du siehst PPPII,PPPII,PPPII,... dann ist das
    Video telecined. Siehst du andere Muster, dann wurde das Video womöglich
    mittels einiger Nicht-Standard-Methoden telecined;
    <application>MEncoder</application> kann ein Nicht-Standard-telecine
    nicht verlustfrei nach progressive konvertieren. Siehst du überhaupt
    keine Muster, ist es höchstwahrscheinlich interlaced.
    </para></listitem>
  </orderedlist>
</para>

<para>
  Manchmal wird telecined Video auf DVDs &quot;hard telecine&quot;
  zugeordnet. Da hard telecine bereits 60000/1001 Felder pro Sekunde hat,
  spielt der DVD-Player das Video ohne irgendeine Manipulation ab.
</para>

<para>
  Ein anderer Weg, zu sagen, ob deine Quelle telecined ist oder nicht,
  ist die Quelle mit den Befehlszeilenoptionen <option>-vf pullup</option>
  und <option>-v</option> abzuspielen, um nachzusehen, wie
  <option>pullup</option> zu den Frames passt.
  Ist die Quelle telecined, solltest du in der Befehlszeile ein 3:2 Muster
  mit abwechselnd <systemitem>0+.1.+2</systemitem> und <systemitem>0++1</systemitem>
  anzeigen.
  Diese Technik hat den Vorteil, dass du die Quelle nicht zu beobachten
  brauchst, um sie zu identifizieren, was von Nutzen sein könnte, falls du
  den Encodiervorgang automatisieren willst oder besagte Prozedur ferngesteuert
  mittels einer langsamen Verbindung vornehmen willst.
</para>

</sect3>

<sect3 id="menc-feat-telecine-ident-interlaced">
<title>Interlaced</title>
<para>
  Interlaced Video wurde ursprünglich als 60000/1001 Felder pro Sekunde
  aufgenommen und auf der DVD als 30000/1001 Frames pro Sekunde abgespeichert.
  Der interlacing-Effekt (oft &quot;combing&quot; genannt) ist ein Ergebnis
  von Kammpaaren von Feldern in Frames. Jedes Feld wird einzeln als
  1/(60000/1001) Sekunden angenommen, und wenn sie simultan angezeigt werden,
  wird der Unterschied offensichtlich.
</para>

<para>
  Wie bei telecined Video sollte <application>MPlayer</application> niemals
  einen Frameratewechsel beim Abspielen des interlaced Inhalts melden.
</para>

<para>
  Wenn du ein interlaced Video genau ansiehst, in dem du dich mit der Taste
  <keycap>.</keycap> durch die Frames bewegst, wirst du sehen, dass
  jeder einzelne Frame interlaced ist.
</para>
</sect3>

<sect3 id="menc-feat-telecine-ident-mixedpt">
<title>Gemischtes progressive und telecine</title>
<para>
  Alle &quot;gemischten progressive und telecine&quot; Videos wurden ursprünglich
  als 24000/1001 Frames pro Sekunde aufgenommen, jedoch werden einige Teile
  telecined beendet.
</para>

<para>
  Spielt <application>MPlayer</application> diese Kategorie ab, wird er
  (oft wiederholt) zwischen &quot;30000/1001 fps NTSC&quot;
  und &quot;24000/1001 fps progressive NTSC&quot; zurück und vor wechseln.
  Beobachte die untere Hälfte von <application>MPlayer</application>s Ausgabe,
  um diese Meldungen anzusehen.
</para>

<para>
  Du solltest die Sektion &quot;30000/1001 fps NTSC&quot; überprüfen, um
  sicher zu gehen, dass sie auch wirklich telecine sind und nicht einfach
  interlaced.
</para>
</sect3>

<sect3 id="menc-feat-telecine-ident-mixedpi">
<title>Gemischtes progressive und interlaced</title>
<para>
  In &quot;gemischtem progressive und interlaced&quot; Inhalt wurde progressive
  und interlaced Video zusammengeklebt.
</para>

<para>
  Diese Kategorie sieht aus wie &quot;gemischtes progressive und telecine&quot;,
  bis du die Sektion 30000/1001 fps untersuchst und feststellst, dass
  sie das telecine-Muster nicht haben.
</para>
</sect3>

</sect2>

<sect2 id="menc-feat-telecine-encode">
<title>Wie jede Kategorie encodieren</title>
<para>
  Wie ich anfangs angemerkt hatte, sind die
  <application>MEncoder</application>-Beispielzeilen unten eigentlich
  <emphasis role="bold">nicht</emphasis> zur Anwendung bestimmt;
  sie demonstrieren nur die Minimalparameter zur korrekten Encodierung
  jeder Kategorie.
</para>

<sect3 id="menc-feat-telecine-encode-progressive">
<title>Progressive</title>
<para>
  Progressive Video erfordert kein spezielles Filtern, um es zu encodieren.
  Der einzige Parameter, den du gewiss anwenden solltest ist
  <option>-ofps 24000/1001</option>. Andernfalls wird
  <application>MEncoder</application> versuchen, bei 30000/1001 fps
  zu encodieren und Frames duplizieren.
</para>

<para>
  <screen>mencoder dvd://1 -oac copy -ovc lavc -ofps 24000/1001</screen>
</para>

<para>
  Dennoch ist es öfters der Fall, dass ein Video, das progressive aussieht,
  eigentlich kurze Teile telecine eingemischt hat. Solange du dir nicht
  sicher bist, ist es am sichersten, das Video als
  <link linkend="menc-feat-telecine-encode-mixedpt">gemischtes progressive und telecine</link>.
  zu behandeln. Der Performance-Verlust ist gering
  <link linkend="menc-feat-telecine-footnotes">[3]</link>.
</para>
</sect3>

<sect3 id="menc-feat-telecine-encode-telecined">
<title>Telecined</title>
<para>
  Telecine kann umgekehrt werden, um den originalen 24000/1001-Inhalt zu erhalten,
  indem man einen Prozess verwendet, der inverse-telecine genannt wird.
  <application>MPlayer</application> enthält verschiedene Filter, um dies
  zu erreichen; der beste Filter, <option>pullup</option> wird in der Sektion
  <link linkend="menc-feat-telecine-encode-mixedpt">Gemischtes progressive und telecine</link>
  beschrieben.
</para>
</sect3>

<sect3 id="menc-feat-telecine-encode-interlaced">
<title>Interlaced</title>
<para>

  In den meisten praktischen Fällen ist es nicht möglich, ein komplett
  progressives Video aus interlaced Inhalt zu erhalten. Der einzige Weg,
  dies ohne den Verlust der Hälfte der vertikalen Auflösung zu erreichen,
  ist das Verdoppeln der Framerate, und man kann versuchen zu
  &quot;schätzen&quot;, wie die korrespondierenden Zeilen für jedes Feld
  vervollständigt werden sollten (dies hat Nachteile - siehe Methode 3).
</para>

<orderedlist>
<listitem><para>
  Das Video in interlaced Form encodieren. Normalerweise richtet Interlacing
  verheerenden Schaden für die Fähigkeit des Encoders an, gut zu komprimieren,
  <systemitem class="library">libavcodec</systemitem> hat jedoch zwei
  eigens für das ein wenig bessere Abspeichern von interlaced Video gedachte
  Parameter: <option>ildct</option> und <option>ilme</option>. Auch wenn
  die Verwendung von <option>mbd=2</option> dringend zu empfehlen ist
  <link linkend="menc-feat-telecine-footnotes">[2]</link>, weil es
  Macroblöcke wie nicht-interlaced an Stellen encodiert, an denen keine Bewegung
  stattfindet. Beachte, dass <option>-ofps</option> hier NICHT notwendig ist.

  <screen>mencoder dvd://1 -oac copy -ovc lavc -lavcopts ildct:ilme:mbd=2</screen>
  </para></listitem>
<listitem><para>
  Nutze einen Deinterlacing-Filter vor dem Encodieren. Es stehen verschiedene
  dieser Filter zur Auswahl, jeder mit seinen eigenen Vor-
  und Nachteilen. Ziehe <option>mplayer -pphelp</option> zu Rate, um zu sehen, welche
  verfügbar sind (suche nach &quot;deint&quot;) und durchsuche die
  <ulink url="http://www.mplayerhq.hu/design7/info.html#mailing_lists">
  MPlayer-Mailinglisten</ulink>, um Diskussionen über die zahlreichen Filter
  zu finden. Nochmals, die Framerate wechselt nicht, also kein
  <option>-ofps</option>. Deinterlacing sollte außerdem nach dem Zuschneiden
  (cropping) <link linkend="menc-feat-telecine-footnotes">[1]</link>
  und vor dem Skalieren angewandt werden.

  <screen>mencoder dvd://1 -oac copy -vf pp=lb -ovc lavc</screen>
  </para></listitem>
<listitem><para>
  Unglücklicherweise arbeitet diese Option im Zusammenhang mit
  <application>MEncoder</application> fehlerhaft; sie sollte mit
  <application>MEncoder G2</application> gut funktionieren, den gibts aber
  noch nicht. Du könntest Abstürze erleben. Seis drum, der Zweck von
  <option> -vf tfields</option> ist es, einen vollen Frame aus jedem Feld
  zu erzeugen, was eine Framerate von 60000/1001 ergibt. Der Vorteil dieses
  Lösungsansatzes ist, dass nie irgendwelche Daten verloren gehen;
  dennoch, da jeder Frame aus nur einem Feld kommt, müssen die fehlenden Zeilen
  irgendwie interpoliert werden. Es gibt keine sehr guten Methoden, die
  fehlenden Daten zu generieren, und so wird das Resultat ein bisschen aussehen,
  als hätte man irgendeinen Deinterlacing-Filter verwendet. Die fehlenden Zeilen
  zu generieren erzeugt auch weitere Probleme, einfach weil sich die Menge
  an Daten verdoppelt. Somit sind höhere Encodier-Bitraten nötig, um
  die Qualität beizubehalten und mehr CPU-Power wird für beides,
  Encodieren und Decodieren, aufgewendet. Das Attribut tfields hat mehrere
  verschiedene Optionen dafür, wie die fehlenden Zeilen jedes Frames erzeugt
  werden.
  Wenn du diese Methode nutzt, dann nimm Bezug auf das Handbuch und wähle,
  welche Option auch immer am besten für dein Material aussieht.
  Beachte, dass du wenn <option>tfields</option> verwendet wird,
  sowohl <option>-fps</option> als auch <option>-ofps</option>spezifizieren <emphasis role="bold">musst</emphasis>,
  um die doppelte Framerate der originalen Quelle zu erhalten.

  <screen>mencoder dvd://1 -oac copy -vf tfields=2 -ovc lavc -fps 60000/1001 -ofps 60000/1001</screen>
  </para></listitem>
<listitem><para>
  Wenn du vorhast, dramatisch herunterzuskalieren, kannst du nur eins
  der beiden Felder extrahieren und encodieren. Sicherlich, du wirst die
  Hälfte der vertikalen Auflösung verlieren, aber wenn du planst, bis auf
  1/2 des Originals herunter zu skalieren, macht der Verlust so gut wie
  gar nichts aus. Das Resultat wird eine progressive Datei mit 30000/1001
  Frames pro Sekunde sein. Die Prozedur ist, <option>-vf field</option>
  zu verwenden, dann die Ränder abzuschneiden
  <link linkend="menc-feat-telecine-footnotes">[1]</link> und angemessen
  zu skalieren. Vergiss nicht, dass du die Skalierung anpassen musst, um
  das Halbieren der vertikalen Auflösung zu kompensieren.
  <screen>mencoder dvd://1 -oac copy -vf field=0 -ovc lavc</screen>
  </para></listitem>
</orderedlist>
</sect3>

<sect3 id="menc-feat-telecine-encode-mixedpt">
<title>Gemischtes progressive und telecine</title>
<para>
  Um progressive und telecine Video komplett in progressive Video
  umzuwandeln, müssen die telecined Teile inverse-telecined werden.
  Die drei Wege, dies zu erreichen, werden unten beschrieben.
  Beachte, dass du inverse-telecine <emphasis role="bold">immer</emphasis>
  vor der Reskalierung durchführen solltest; es sei denn, du weißt wirklich,
  was du tust; mache inverse-telecine auch vor dem Entfernen der Ränder
  <link linkend="menc-feat-telecine-footnotes">[1]</link>.
  <option>-ofps 24000/1001</option> wird hier benötigt, weil das Output-Video
  24000/1001 Frames pro Sekunde werden soll.
</para>

<itemizedlist>
<listitem><para>
  <option>-vf pullup</option> wurde entworfen, um auf telecined Material
  inverse-telecine anzuwenden, während die progressiven Daten unangetastet
  bleiben. Damit dies richtig funktioniert, <emphasis role="bold">muss</emphasis>
  <option>pullup</option> vom <option>softskip</option>-Filter gefolgt werden, sonst
  wird <application>MEncoder</application> abstürzen.
  <option>pullup</option> ist trotz allem die sauberste und akkurateste
  Methode, die zum Encodieren von beidem telecine und
  &quot;gemischtem progressive und telecine&quot; zur Verfügung steht.

  <screen>mencoder dvd://1 -oac copy -vf pullup,softskip -ovc lavc -ofps 24000/1001</screen>
  </para>


  </listitem>
  <listitem><para>
  Eine ältere Methode ist, anstatt inverse-telecine auf die telecined Teile
  anzuwenden, telecine auf nicht-telecined Teile und dann inverse-telecine auf das
  ganze Video anzuwenden. Hört sich verwirrend an? softpulldown ist
  ein Filter, der ein Video durchgeht und die komplette Datei telecined macht.
  Lassen wir auf softpulldown entweder <option>detc</option> oder <option>ivtc</option>
  folgen, wird das Endergebnis vollkommen progressiv. <option>-ofps 24000/1001</option>
  wird benötigt.

  <screen>mencoder dvd://1 -oac copy -vf softpulldown,ivtc=1 -ovc lavc -ofps 24000/1001</screen>
  </para>
  </listitem>

<listitem><para>
  Ich habe <option>-vf filmdint</option> selbst verwendet, aber lies hier, was
  D Richard Felker III zu erzählen hat:

  <blockquote><para>Es ist OK, aber IMO versucht er zu oft eher ein deinterlace
    als ein inverse telecine durchzuführen (ganz wie Settop-DVD-Player
    &amp; progressive TVs), was ein hässliches Flimmern erzeugt und
    andere Artefakte. Wenn du vorhast, es anzuwenden, musst du zumindest
    einige Zeit darauf verwenden, die Optionen zu tunen und zuerst den Output
    zu beobachten, damit du auch sicher sein kannst, dass du nichts
    vermasselst.</para></blockquote>
  </para></listitem>
</itemizedlist>
</sect3>

<sect3 id="menc-feat-telecine-encode-mixedpi">
<title>Gemischtes progressive und interlaced</title>
<para>
  Es gibt zwei Optionen für den Umgang mit dieser Kategorie, jede von
  beiden stellt einen Kompromiss dar. Du solltest basierend auf
  Dauer/Stelle jedes Typs entscheiden.
</para>

<itemizedlist>
<listitem><para>
  Behandle es wie progressive. Die interlaced Teile werden interlaced
  aussehen und einige der interlaced Felder müssen weggelassen werden,
  was ein wenig zu Sprüngen führt. Du kannst einen
  Nachbearbeitungsfilter verwenden, wenn du willst, aber dies wird die
  progressive-Anteile geringfügig verringern.
  </para>

  <para>
  Diese Option sollte definitiv nicht verwendet werden, wenn du eventuell
  Video auf einem interlaced Gerät anzeigen willst (mit einer TV-Karte
  zum Beispiel). Wenn du interlaced Frames in einem Video mit 24000/1001
  Frames pro Sekunde hast, werden diese zusammen mit den progressive
  Frames telecined. Die Hälfte der interlaced &quot;Frames&quot; werden für die
  Dauer von drei Feldern (3/(60000/1001) Sekunden) angezeigt, was
  einen flimmernden &quot;Zeitrücksprung&quot;-Effekt zur Folge hat, der
  ziemlich schlecht aussieht. Solltest du dies dennoch versuchen,
  <emphasis role="bold">musst</emphasis> du einen
  Deinterlacing-Filter wie <option>lb</option> oder <option>l5</option>
  anwenden.
  </para>

  <para>
  Es wäre auch keine gute Idee für eine progressive Anzeige. Es wird
  Paare aufeinander folgender interlaced Felder auslassen, was eine
  Unstetigkeit zur Folge hat, die eher sichtbar ist als mit der
  zweiten Methode, die einige progressive Frames zweimal anzeigt.
  Ein interlaced Video mit 30000/1001 Frames pro Sekunde ist bereits
  ein bisschen abgehackt, weil es wirklich mit 60000/1001 Felder pro
  Sekunde angezeigt werden sollte, sodass sich die doppelten Frames
  nicht zu sehr abzeichnen.
  </para>

  <para>
  Egal welchen Weg du wählst, es ist das beste, deinen Inhalt
  zu berücksichtigen und wie du ihn anzeigen willst. Ist dein Video
  zu 90% progressive und du hast nie vor, es auf einem TV-Bildschirm
  anzuzeigen, solltest du einen progressive-Ansatz wählen. Ist es nur
  halb-progressive, willst du es eventuell so encodieren, als sei alles
  interlaced.
  </para>
  </listitem>

<listitem><para>
  Behandle es wie interlaced. Einige Frames des progressive-Anteils
  müssen dupliziert werden, was zu Sprüngen führt. Nochmal,
  Deinterlacing-Filter können die progressive-Anteile leicht verringern.
  </para></listitem>

</itemizedlist>
</sect3>

</sect2>

<sect2 id="menc-feat-telecine-footnotes">
<title>Fußnoten</title>
<orderedlist>
<listitem><formalpara>
  <title>Über das Zuschneiden (cropping):</title>
  <para>
  Videodaten auf DVDs werden in einem YUV 4:2:0 genannten Format abgelegt.
  In einem YUV-Video, werden Helligkeit und Chrominanz separat gespeichert.
  Da das menschliche Auge ein bisschen weniger empfindlich auf Farbe
  reagiert als auf Helligkeit, ist in einem YUV 4:2:0 Bild nur ein
  Chrominanz-Pixel für alle vier Helligkeits-Pixel vorhanden.
  In einem progressive Bild, besitzt jedes Quadrat von vier luma-Pixeln (zwei
  auf jeder Seite) ein gemeinsames chroma-Pixel. Du musst progressive YUV
  4:2:0 zu geradzahligen Auflösungen zurechtschneiden und geradzahlige
  Offsets verwenden. Zum Beispiel ist
  <option>crop=716:380:2:26</option> OK,
  <option>crop=716:380:3:26 </option> aber nicht.
  </para>
  </formalpara>

  <para>
  Wenn du es mit interlaced YUV 4:2:0 zu tun hast, ist die Situation
  ein wenig komplizierter. Anstatt dass immer vier luma-Pixel im
  <emphasis>Frame</emphasis> sich ein chroma-Pixel teilen, teilen sich
  immer vier luma-Pixel in jedem <emphasis>Feld</emphasis> ein
  chroma-Pixel. Wenn Felder zur Formung eines Frames interlaced werden,
  ist jede Scanzeile ein Pixel hoch. Jetzt liegen anstatt je vier
  luma-Pixel in einem Quadrat immer zwei Pixel nebeneinander und die
  anderen zwei Pixel liegen zwei Scanzeilen weiter unten nebeneinander.
  Die zwei luma-Pixel in der dazwischen liegenden Scanzeile sind vom
  anderen Feld und teilen sich somit ein anderes chroma-Pixel mit
  zwei luma-Pixeln zwei Scanzeile entfernt. All diese Konfusion macht
  es notwendig, vertikale Ausschneide-Abmessungen und Offsets zu
  haben, die ein Vielfaches von vier sind. Horizontal kann geradzahlig
  bleiben.
  </para>

  <para>
  Für telecined Video empfehle ich, das Zuschneiden nach dem inverse
  telecining stattfinden zu lassen. Ist das Video einmal progressive,
  musst du nur noch mit geraden Zahlen zuschneiden. Wenn du wirklich die
  leichte Beschleunigung haben willst, die zuerst zuzuschneiden
  möglicherweise bietet, musst du vertikal mit einem Vielfachen von vier
  zuschneiden, oder der inverse-telecine Filter wird keine korrekten Daten
  haben.
  </para>

  <para>
  Für interlaced (nicht telecined) Video musst du immer
  mit einem Vielfachen von vier zuschneiden, es sei denn, du verwendest
  <option>-vf field</option> vor dem Schneiden.
  </para>
  </listitem>

<listitem><formalpara>
  <title>Über Encodier-Parameter und Qualität:</title>
  <para>
  Nur weil ich hier <option>mbd=2</option> vorschlage, heißt das nicht,
  dass es woanders benutzt werden soll. Zusammen mit <option>trell</option>
  ist <option>mbd=2</option> eine der Optionen von
  <systemitem class="library">libavcodec</systemitem>, welche die
  Qualität am deutlichsten heben, und du solltest stets das letzte der beiden
  anwenden, außer das Abfallen der Encodiergeschwindigkeit ist abschreckend
  hoch (z.B. Encodierung in Echtzeit). Es gibt eine Menge anderer Optionen für
  <systemitem class="library">libavcodec</systemitem>, die die Encodierqualität
  verbessern (und die Encodiergeschwindigkeit verringern), dies liegt aber jenseits
  des Rahmens dieses Dokuments.
  </para>
  </formalpara>
  </listitem>

<listitem><formalpara>
  <title>Über die Performance von pullup:</title>
  <para>
  <option>Pullup</option> kann sicher (zusammen mit <option>softskip</option>)
  auf progressive Video angewandt werden und ist für gewöhnlich eine gute Idee,
  es sei denn, die Quelle wurde definitiv als vollkommen progressive verifiziert.
  Der Performaceverlust ist in den meisten Fällen gering. Bei einer Minimalencodierung
  macht <option>pullup</option> <application>MEncoder</application>
  50% langsamer. Das Hinzufügen von Soundverarbeitung und erweiterten
  <option>lavcopts</option> überschattet diesen Unterschied
  und drückt den Performanceabfall, der mit dem Verwenden von <option>pullup</option>
  verbunden war, runter auf 2%.
  </para>
  </formalpara>
  </listitem>

</orderedlist>

</sect2>

</sect1>


<sect1 id="menc-feat-enc-libavcodec">
<title>Encodieren mit der <systemitem class="library">libavcodec</systemitem>
  Codecfamilie</title>

<para>
<link linkend="ffmpeg"><systemitem class="library">libavcodec</systemitem></link>
  stellt einfache Encodierung für eine Menge interessanter Video- und Audioformate
  zur Verfügung.
  Du kannst folgende Codecs encodieren (mehr oder weniger aktuell):
</para>

<sect2 id="menc-feat-enc-libavcodec-video-codecs">
<title>Videocodecs von <systemitem class="library">libavcodec</systemitem></title>

<para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row><entry>Name des Videocodecs</entry><entry>Beschreibung</entry></row>
</thead>
<tbody>
<row><entry>mjpeg</entry><entry>
   Motion-JPEG
  </entry></row>
<row><entry>ljpeg</entry><entry>
   Verlustfreies JPEG
  </entry></row>
<row><entry>h261</entry><entry>
  H.261
  </entry></row>
<row><entry>h263</entry><entry>
  H.263
  </entry></row>
<row><entry>h263p</entry><entry>
  H.263+
  </entry></row>
<row><entry>mpeg4</entry><entry>
  ISO Standard MPEG-4 (DivX 5, XviD-kompatibel)
  </entry></row>
<row><entry>msmpeg4</entry><entry>
  Pre-Standard MPEG-4 Variante von MS, v3 (AKA DivX3)
  </entry></row>
<row><entry>msmpeg4v2</entry><entry>
  Pre-Standard MPEG-4 von MS, v2 (in alten ASF-Dateien verwendet)
  </entry></row>
<row><entry>wmv1</entry><entry>
  Windows Media Video, Version 1 (AKA WMV7)
  </entry></row>
<row><entry>wmv2</entry><entry>
  Windows Media Video, Version 2 (AKA WMV8)
  </entry></row>
<row><entry>rv10</entry><entry>
  RealVideo 1.0
  </entry></row>
<row><entry>rv20</entry><entry>
  RealVideo 2.0
  </entry></row>
<row><entry>mpeg1video</entry><entry>
  MPEG-1 Video
  </entry></row>
<row><entry>mpeg2video</entry><entry>
  MPEG-2 Video
  </entry></row>
<row><entry>huffyuv</entry><entry>
  Verlustfreie (lossless) Kompression
  </entry></row>
<row><entry>asv1</entry><entry>
  ASUS Video v1
  </entry></row>
<row><entry>asv2</entry><entry>
  ASUS Video v2
  </entry></row>
<row><entry>ffv1</entry><entry>
  FFmpeg's verlustfreier (lossless) Videocodec
  </entry></row>
<row><entry>svq1</entry><entry>
  Sorenson Video 1
  </entry></row>
<row><entry>flv</entry><entry>
  Sorenson H.263, der in Flash Video benutzt wird
  </entry></row>
<row><entry>dvvideo</entry><entry>
 Sony Digital Video
  </entry></row>
<row><entry>snow</entry><entry>
  FFmpeg's experimenteller Wavelet-basierter Codec
  </entry></row>
</tbody>
</tgroup>
</informaltable>

  Die erste Spalte enthält die Codecnamen, die nach der Konfiguration
  <literal>vcodec</literal> übergeben werden müssen, wie:
  <option>-lavcopts vcodec=msmpeg4</option>
</para>
<informalexample>
<para>
  Ein Beispiel mit MJPEG-Komprimierung:
  <screen>mencoder dvd://2 -o title2.avi -ovc lavc -lavcopts vcodec=mjpeg -oac copy</screen>
</para>
</informalexample>
</sect2>

<sect2 id="menc-feat-enc-libavcodec-audio-codecs">
<title>Audiocodecs von <systemitem class="library">libavcodec</systemitem></title>
<para>
<informaltable frame="all">
<tgroup cols="2">
<thead>
<row><entry>Name des Audiocodecs</entry><entry>Beschreibung</entry></row>
</thead>
<tbody>
  <row>
    <entry>mp2</entry>
    <entry>MPEG Layer 2</entry>
  </row>
  <row>
    <entry>ac3</entry>
    <entry>AC3, AKA Dolby Digital</entry>
  </row>
  <row>
    <entry>adpcm_ima_wav</entry>
    <entry>IMA adaptive PCM (4 Bit pro Sample, 4:1-Kompression)</entry>
  </row>
  <row>
    <entry>sonic</entry>
    <entry>experimenteller verlustbehafteter/verlustfreier Codec</entry>
  </row>
</tbody>
</tgroup>
</informaltable>

  Die erste Spalte enthält die Codecnamen, die nach der Konfiguration
  <literal>acodec</literal> übergeben werden müssen, wie:
  <option>-lavcopts acodec=ac3</option>
</para>

<informalexample>
<para>
Ein Beispiel mit AC3-Kompression:
<screen>mencoder dvd://2 -o title2.avi -oac lavc -lavcopts acodec=ac3 -ovc copy</screen>
</para>
</informalexample>

<para>
  Im Gegensatz zu den Videocodecs von <systemitem class="library">libavcodec</systemitem>
  machen dessen Audiocodecs keinen weisen Gebrauch von den Bits, die ihnen übergeben
  werden, da es ihnen an einem minimalen psychoakustischen Modell fehlt (falls
  überhaupt eins vorhanden ist), wodurch sich die meisten anderen
  Codec-Implementierungen auszeichnen.
  Beachte jedoch, dass all diese Audiocodecs sehr schnell sind und überall dort
  hervorragend arbeiten, wo <application>MEncoder</application> mit
  <systemitem class="library">libavcodec</systemitem> kompiliert wurde (was
  meistens der Fall ist) und nicht von externen Programmbibliotheken abhängt.
</para>
</sect2>


<sect2 id="menc-feat-dvd-mpeg4-lavc-encoding-options">
<title>Encodieroptionen von libavcodec</title>

<para>
  Idealerweise möchtest du eventuell in der Lage sein, dem Encoder einfach zu sagen,
  er soll in den &quot;hochqualitativen&quot; Modus wechseln und weiter machen.
  Das wäre vermutlich nett, aber unglücklicherweise schwer zu implementieren, da
  verschiedene Encodieroptionen unterschiedliche Qualitätsresultate hervorbringen,
  abhängig vom Quellmaterial.
  Das liegt daran, dass die Komprimierung von den visuellen Eigenschaften des fraglichen Videos abhängt.
  Zum Beispiel haben Anime und Live-Action sehr unterschiedliche Eigenschaften und
  benötigen aus diesm Grund verschiedene Optionen, um optimale Encodierung zu erreichen.
  Die gute Neuigkeit ist, dass einige Optionen wie <option>mbd=2</option>,
  <option>trell</option> und <option>v4mv</option> nie ausgelassen werden sollten.
  Siehe unten nach der detaillierten Beschreibung allgemeiner Encodieroptionen.
</para>


<itemizedlist>
<title>Anzupassende Optionen:</title>
<listitem><para>
  <emphasis role="bold">vmax_b_frames</emphasis>: 1 oder 2 ist gut, abhängig vom
  Film.
  Beachte, dass du, falls deine Encodierung von DivX5 decodierbar sein muss, den
  Support für "closed GOP" aktivieren musst, indem du die
  <systemitem class="library">libavcodec</systemitem>-Option <option>cgop</option>
  verwendest, du musst jedoch Szenenerkennung deaktivieren, was wiederum keine gute
  Idee ist, da es die Ecodierungseffizienz etwas angreift.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vb_strategy=1</emphasis>: hilft in Szenen mit viel
  Bewegung (high-motion).
  Bei manchen Videos wird vmax_b_frames der Qualität schaden, vmax_b_frames=2
  zusammen mit vb_strategy=1 hilft jedoch.
</para></listitem>

<listitem><para>
  <emphasis role="bold">dia</emphasis>: Bewegungssuchbereich. Größer ist besser
  als kleiner.
  Negative Werte sind ein komplett anderer Maßstab.
  Gute Werte sind -1 für ein schnelle oder 2-4 für langsame Encodierung.
</para></listitem>

<listitem><para>
  <emphasis role="bold">predia</emphasis>: Bewegungssuche Vorabdurchlauf (pre-pass).
  Nicht so wichtig wie dia. Gute Werte sind 1 (Standard) bis 4. Erfordert preme=2, um
  wirklich was zu nützen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">cmp, subcmp, precmp</emphasis>: Vergleichsfunktion zur
  Bewegungseinschätzung.
  Experimentiere mit Werten von 0 (Standard), 2 (hadamard), 3 (dct) und
  6 (Ratenverzerrung).
  0 ist am schnellsten und ausreichend für precmp.
  Für cmp und subcmp ist 2 gut bei Anime, und 3 ist gut bei Live-Action.
  6 kann leicht besser sein oder auch nicht, ist aber langsam.
</para></listitem>

<listitem><para>
  <emphasis role="bold">last_pred</emphasis>: Anzahl der Bewegungsvorhersagen, die
  vom vorherigen Frame genommen werden sollen.
  1-3 oder so hilft bei geringer Geschwindigkeitseinbuße.
  Höhere Werte sind langsam bei keinerlei Zusatzgewinn.
</para></listitem>

<listitem><para>
  <emphasis role="bold">cbp, mv0</emphasis>: Kontrolliert die Auswahl von Macroblöcken.
  Kleine Geschwindigkeitseinbußen bei kleinem Qualitätsgewinn.
</para></listitem>

<listitem><para>
  <emphasis role="bold">qprd</emphasis>: adaptive Quantisierung basierend auf der
  Komplexität des Macroblocks.
  Kann hilfreich sein oder schaden, abhängig vom Video und anderen Optionen.
  Dies kann Artefakte verursachen, es sei denn, du setzt vqmax auf einen halbwegs
  kleinen Wert (6 ist gut, vielleicht so langsam wie 4); vqmin=1 sollte ebenfalls
  helfen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">qns</emphasis>: sehr langsam, speziell wenn kombiniert
  mit qprd.
  Diese Option veranlasst den Encoder, durch Kompressionsartefakte entstandenes
  Rauschen zu minimieren anstatt das encodierte Video strikt der Quelle anzupassen.
  Verwende dies nicht, es sei denn du, hast bereits alles andere so weit wie möglich
  optimiert und die Resultate sind immer noch nicht gut genug.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vqcomp</emphasis>: Frequenzkontrolle optimieren.
  Welche Werte gut sind, hängt vom Film ab.
  Du kannst dies sicher so lassen wie es ist, wenn du willst.
  Wird vqcomp verringert, werden mehr Bits auf Szenen mit geringer Komlexität
  gelegt, wird es erhöht, legt es diese Bits auf Szenen mit hoher Komlexität
  (Standard: 0.5, Bereich: 0-1. empfohlener Bereich: 0.5-0.7).
</para></listitem>

<listitem><para>
  <emphasis role="bold">vlelim, vcelim</emphasis>: Setzt die Schwelle für die
  Eliminierung einzelner Koeffizienten bei Helligkeits- und Farbanteilen.
  Sie werden in allen MPEG-ähnlichen Algorithmen getrennt encodiert.
  Die Idee hinter diesen Optionen ist, einige gute Heuristiken zu verwenden,
  um zu bestimmen, wenn ein Wechsel innerhalb eines Blocks kleiner als der
  der von dir festgelegte Schwellenwert ist und in solch einem Fall den
  Block einfach so zu encodieren als fände &quot;kein Wechsel&quot; statt.
  Das spart Bits und beschleunigt womöglich die Encodierunng. vlelim=-4 und vcelim=9
  scheinen gut für Live-Filme zu sein, helfen aber scheinbar nicht bei Anime;
  beim Encodieren einer Animation solltest du sie womöglich unverändert lassen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">qpel</emphasis>: Bewegungsabschätzung auf ein viertel
  Pixel (quarter pel).
  MPEG-4 verwendet als Voreinstellung eine Halbpixel-Genauigkeit für die Bewegungssuche,
  deswegen hat diese Option einen Overhead, da mehr Informationen in der
  encodierte Datei untergebracht werden.
  Der Kompressionsgewinn/-verlust hängt vom Film ab, ist aber in der Regel nicht
  sonderlich effektiv bei Anime.
  qpel zieht immer eine signifikante Erhöhung der CPU-Decodierzeit nach
  sich (+25% in der Praxis).
</para></listitem>

<listitem><para>
  <emphasis role="bold">psnr</emphasis>: wirkt sich eigentlich nicht auf
  das Encodieren aus, schreibt jedoch eine Log-Datei mit Typ/Größe/Qualität
  jedes Frames und gibt am Ende die Summe des PSNR Signal-zu-Rauschabstands
  (Peak Signal to Noise Ratio) aus.
</para></listitem>

</itemizedlist>

<itemizedlist>
<title>Optionen, mit denen besser nicht herumgespielt werden sollte:</title>
<listitem><para>
  <emphasis role="bold">vme</emphasis>: Der Standardwert ist der beste.
</para></listitem>

<listitem><para>
  <emphasis role="bold">lumi_mask, dark_mask</emphasis>: Psychovisuell adaptive
  Quantisierung.
  Du solltest nicht im Traum daran denken, mit diesen Optionen herumzuspielen,
  wenn dir Qualität wichtig ist.
  Vernünftige Werte mögen in deinem Fall effektiv sein, aber sei gewarnt,
  dies ist sehr subjektiv.
</para></listitem>

<listitem><para>
  <emphasis role="bold">scplx_mask</emphasis>: Versucht, Blockartefakte
  zu verhindern, Postprocessing ist aber besser.
</para></listitem>
</itemizedlist>
</sect2>

<sect2 id="menc-feat-mpeg4-lavc-example-settings">
<title>Beispiele für Encodierungseinstellungen</title>

<para>
  Die folgenden Einstellungen sind Beispiele verschiedener Kombinationen
  von Encodierungsoptionen, die den Kompromiss Geschwindigkeit gegenüber
  Qualität bei gleicher Zielbitrate beeinflussen.
</para>

<para>
  Alle Encodierungseinstellungen wurden auf einem Beispielvideo
  mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps und
  der Rechner war ein AMD-64 3400+ mit 2400 Mhz im 64bit-Modus.
  Jede Encodiereinstellung zeichnet sich aus durch die gemessene
  Encodiergeschwindigkeit (in Frames pro Sekunde) und den PSNR-Verlust
  (in dB) im Vergleich zu Einstellungen für &quot;sehr hohe Qualität&quot;.
  Bitte habe Verständnis, dass du abhängig von deiner Quelldatei,
  deinem Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche
  Resultate erzielen wirst.
</para>

<para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row><entry>Beschreibung</entry><entry>Encodieroptionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
</thead>
<tbody>
<row>
  <entry>Sehr hohe Qualität</entry>
  <entry><option>vcodec=mpeg4:mbd=2:mv0:trell:v4mv:cbp:last_pred=3:predia=2:dia=2:vmax_b_frames=2:vb_strategy=1:precmp=2:cmp=2:subcmp=2:preme=2:qns=2</option></entry>
  <entry>6fps</entry>
  <entry>0dB</entry>
</row>
<row>
  <entry>Hohe Qualität</entry>
  <entry><option>vcodec=mpeg4:mbd=2:trell:v4mv:last_pred=2:dia=-1:vmax_b_frames=2:vb_strategy=1:cmp=3:subcmp=3:precmp=0:vqcomp=0.6:turbo</option></entry>
  <entry>15fps</entry>
  <entry>-0.5dB</entry>
</row>
<row>
  <entry>Schnell</entry>
  <entry><option>vcodec=mpeg4:mbd=2:trell:v4mv:turbo</option></entry>
  <entry>42fps</entry>
  <entry>-0.74dB</entry>
</row>
<row>
  <entry>Echtzeit</entry>
  <entry><option>vcodec=mpeg4:mbd=2:turbo</option></entry>
  <entry>54fps</entry>
  <entry>-1.21dB</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

<sect2 id="custommatrices"><title>Maßgeschneiderte inter/intra-Matrizen</title>

<para>
Mit diesem Feature von <link linkend="ffmpeg"><systemitem class="library">libavcodec</systemitem></link>
bist du in der Lage, eigene inter- (I-Frames/Keyframes) und intra-Matrizen
(P-Frames/predicted Frames) zu setzen. Es wird von vielen Codecs unterstützt:
<systemitem>mpeg1video</systemitem> und <systemitem>mpeg2video</systemitem>
sollen damit funktionieren.
</para>

<para>
Eine typische Anwendung dieses Features ist, die von den
<ulink url="http://www.kvcd.net/">KVCD</ulink>-Specifikationen
bevorzugten Matrizen zu setzen.
</para>

<para>
Die <emphasis role="bold">KVCD &quot;Notch&quot; Quantisierungsmatrix:</emphasis>
</para>

<para>
Intra:
<screen>
 8  9 12 22 26 27 29 34
 9 10 14 26 27 29 34 37
12 14 18 27 29 34 37 38
22 26 27 31 36 37 38 40
26 27 29 36 39 38 40 48
27 29 34 37 38 40 48 58
29 34 37 38 40 48 58 69
34 37 38 40 48 58 69 79
</screen>

Inter:
<screen>
16 18 20 22 24 26 28 30
18 20 22 24 26 28 30 32
20 22 24 26 28 30 32 34
22 24 26 30 32 32 34 36
24 26 28 32 34 34 36 38
26 28 30 32 34 36 38 40
28 30 32 34 36 38 42 42
30 32 34 36 38 40 42 44
</screen>
</para>

<para>
Anwendung:
<screen>
$ mencoder <replaceable>input.avi</replaceable> -o <replaceable>output.avi</replaceable> -oac copy -ovc lavc -lavcopts inter_matrix=...:intra_matrix=...
</screen>
</para>

<para>
<screen>
$ mencoder <replaceable>input.avi</replaceable> -ovc lavc -lavcopts
vcodec=mpeg2video:intra_matrix=8,9,12,22,26,27,29,34,9,10,14,26,27,29,34,37,
12,14,18,27,29,34,37,38,22,26,27,31,36,37,38,40,26,27,29,36,39,38,40,48,27,
29,34,37,38,40,48,58,29,34,37,38,40,48,58,69,34,37,38,40,48,58,69,79
:inter_matrix=16,18,20,22,24,26,28,30,18,20,22,24,26,28,30,32,20,22,24,26,
28,30,32,34,22,24,26,30,32,32,34,36,24,26,28,32,34,34,36,38,26,28,30,32,34,
36,38,40,28,30,32,34,36,38,42,42,30,32,34,36,38,40,42,44 -oac copy -o svcd.mpg
</screen>
</para>
</sect2>


<sect2 id="menc-feat-dvd-mpeg4-example">
<title>Beispiel</title>

<para>
  Jetzt hast du gerade eben deine brandneue Kopie von Harry Potter und die
  Kammer des Schreckens gekauft (natürlich die Breitbildedition), und du
  willst diese DVD so rippen, dass du sie deinem Home Theatre PC hinzufügen
  kannst. Dies ist eine Region-1-DVD, also ist sie NTSC. Das unten stehende
  Beispiel wird auch auf PAL zutreffen, nur dass du
  <option>-ofps 24000/1001</option> weglässt (weil die Ausgabeframerate die
  gleiche ist wie die Eingabeframerate), und logischerweise werden die
  Ausschnittsabmessungen anders sein.
</para>

<para>
  Nach dem Start von <option>mplayer dvd://1</option>, verfolgen wir den
  detailliert in der Sektion <link linkend="menc-feat-telecine">Wie mit telecine
  und interlacing in NTSC-DVDs umgehen</link> beschriebenen Prozess und
  entdecken, dass es progressive Video mit 24000/1001 fps ist, was bedeutet, dass
  wir keinen inverse telecine-Filter wie <option>pullup</option> oder
  <option>filmdint</option> anwenden müssen.
</para>

<para>
  Als Nächstes wollen wir das passende Ausschnittsrechteck bestimmen, also
  verwenden wir den crop-Erkennungsfilter:

  <screen>mplayer dvd://1 -vf cropdetect</screen>

  Stelle sicher, dass du einen voll gefüllten Frame anstrebst (wie zum
  Beispiel eine helle Szene), und dass du diese Ausgabe in
  <application>MPlayer</application>s Konsole siehst:

  <screen>crop area: X: 0..719  Y: 57..419  (-vf crop=720:362:0:58)</screen>

  Wir spielen den Film dann mit diesem Filter ab, um seine Korrektheit zu testen:

  <screen>mplayer dvd://1 -vf crop=720:362:0:58</screen>

  Und wir sehen, dass er einfach perfekt aussieht. Als Nächstes vergewissern wir
  uns, dass Breite und Höhe ein Vielfaches von 16 sind. Die Breite ist gut,
  aber die Höhe ist es nicht. Da wir in der 7-ten Klasse in Mathe nicht gefehlt
  haben, wissen wir, dass das am nähesten liegende Vielfache von 16 kleiner
  als 362 der Wert 352 ist (Taschenrechner ist erlaubt).
</para>

<para>
  Wir könnten einfach <option>crop=720:352:0:58</option> verwenden, aber es wäre
  nett, ein bisschen von oben und ein bisschen von unten wegzunehmen, sodass
  wir zentriert bleiben. Wir haben die Höhe um 10 Pixel schrumpfen lassen, aber
  wir wollen das y-Offset nicht um 5 Pixel erhöhen, da dies eine ungerade Zahl
  ist und die Qualität nachteilig beeinflussen würde. Statt dessen werden wir
  das y-Offset um 4 Pixel erhöhen:

  <screen>mplayer dvd://1 -vf crop=720:352:0:62</screen>

  Ein anderer Grund, Pixel von beidem - oben und unten - abzuschnipseln ist,
  dass wir sicher gehen wollen, jegliches halbschwarze Pixel eliminiert zu
  haben, falls welche existieren. Beachte, falls das Video telecined
  ist, stelle sicher, dass der <option>pullup</option>-Filter (oder für
  welchen umgekehrten telecine-Filter auch immer du dich entschieden hast)
  in der Filterkette auftaucht, bevor du zuschneidest. Ist es interlaced,
  deinterlace es vor dem Zuschneiden.
  (Wenn du dich entscheidest, interlaced Video beizubehalten, dann vergewissere dich, dass
  das vertikale crop-Offset ein Vielfaches von 4 ist.)
</para>

<para>
  Wenn du wirklich besorgt um den Verlust dieser 10 Pixel bist, ziehst du
  statt dessen etwa das Herunterskalieren der Abmessungen auf das am nächsten
  liegende Vielfache von 16 vor.
  Die Filterkette würde dann etwa so aussehen:

  <screen>-vf crop=720:362:0:58,scale=720:352</screen>

  Das Video auf diese Art herunter zu skalieren wird bedeuten, dass eine
  kleine Menge Details verloren geht, obwohl es vermutlich nicht wahrnehmbar
  sein wird. Hoch zu skalieren führt zu niedrigerer Qualität (es sei denn,
  du erhöhst die Bitrate). Ausschneiden sondert sämtliche dieser Pixel
  aus. Es ist ein Kompromiss, den du unter allen Umständen
  in Betracht ziehen solltest. Zum Beispiel, wenn das DVD-Video für das Fernsehen
  hergestellt wurde, solltest du vertikales Skalieren vermeiden, da das
  Zeilensampling mit der Art und Weise korrespondiert, für die der Inhalt
  ursprünglich aufgenommen wurde.
</para>

<para>
  Bei der Überprüfung sehen wir, dass unser Film ordentlich Action enthält
  und sehr viele Details, also wählen wir 2400Kbit für unsere Bitrate.
</para>

<para>
  Wir sind nun bereit, die 2-pass Encodierung durchzuführen. Erster Durchlauf:

  <screen>mencoder dvd://1 -ofps 24000/1001 -oac copy -vf pullup,softskip,crop=720:352:0:62,hqdn3d=2:1:2 -ovc lavc \
-lavcopts vcodec=mpeg4:vbitrate=2400:v4mv:mbd=2:trell:cmp=3:subcmp=3:mbcmp=3:autoaspect:vpass=1 \
-o Harry_Potter_2.avi</screen>

  Und der zweite Durchlauf ist derselbe, außer dass wir <option>vpass=2</option>
  festlegen:

  <screen>mencoder dvd://1 -ofps 24000/1001 -oac copy -vf pullup,softskip,crop=720:352:0:62,hqdn3d=2:1:2 -ovc lavc \
-lavcopts vcodec=mpeg4:vbitrate=2400:v4mv:mbd=2:trell:cmp=3:subcmp=3:mbcmp=3:autoaspect:vpass=2 \
-o Harry_Potter_2.avi</screen>
</para>

<para>
  Die Optionen <option>v4mv:mbd=2:trell</option> werden die Qualität
  außerordentlich erhöhen, auf Kosten der Encodierdauer. Es gibt
  einen kleinen Grund, diese Optionen auszulassen, wenn das Primärziel
  die Qualität ist. Die Optionen
  <option>cmp=3:subcmp=3:mbcmp=3</option> wählen eine Vergleichsfunktion,
  die eine höhere Qualität liefert als die Standardeinstellungen.
  Du darfst mit diesem Parameter rumexperimentieren (ziehe die Manpage
  zu möglichen Werten zu Rate) da verschiedene Funktionen abhängig vom
  Quellmaterial einen starken Einfluss auf die Qualität haben. Wenn du zum Beispiel
  meinst, dass <systemitem class="library">libavcodec</systemitem> zu
  viele Blockartefakte produziert, könntest du ja das experimentelle
  NSSE als Vergleichsfunktion via <option>*cmp=10</option> wählen.
</para>

<para>
  Für diesen Film wird das resultierende AVI 138 Minuten lang und nahezu
  3GB groß sein. Und weil du erzählt hast, dass eine große Datei nichts
  ausmacht, ist dies eine perfekt akzeptierbare Größe. Wolltest du sie aber
  kleiner haben, könntest du eine niedrigere Bitrate hernehmen. Erhöhte
  Bitraten haben verminderte Rückgaben, während wir also deutlich eine
  Verbesserung von 1800Kbit nach 2000Kbit sehen, ist es oberhalb 2000Kbit
  nicht so auffällig. Fühl dich frei solange herum zu experimentieren bis
  du glücklich bist.
</para>

<para>
  Weil wir das Quellvideo durch einen Denoise-Filter geschickt haben,
  könntest du einige davon während des Playbacks wieder hinzufügen wollen.
  Dies zusammen mit dem Nachbearbeitungsfilter <option>spp</option>
  verbessert die Wahrnehmung der Qualität drastisch und hilft dabei,
  blockhafte Artefakte aus dem Video zu eliminieren.
  Mit <application>MPlayer</application>s Option <option>autoq</option>
  kannst du den Nachbearbeitungsaufwand des spp-Filters abhängig von der
  verfügbaren CPU variieren. An dieser Stelle kannst du auch Gamma- und/oder
  Farbkorrektur zur besten Anpassung an dein Display verwenden, wenn du willst.
  Zum Beispiel:

  <screen>mplayer Harry_Potter_2.avi -vf spp,noise=9ah:5ah,eq2=1.2 -autoq 3</screen>

</para>
</sect2>
</sect1>


<sect1 id="menc-feat-xvid">
<title>Encodieren mit dem <systemitem class="library">XviD</systemitem>-Codec</title>
<para>
 <systemitem class="library">XviD</systemitem> ist eine freie
 Programmbibliothek zum Encodieren von MPEG-4 ASP-Videostreams.
 Bevor du mit <link linkend="xvid"> zu encodieren beginnst, musst du
 <application>MEncoder</application> so einstellen, dass er es unterstützt</link>.
</para>
<para>
 Dieses Handbuch beabsichtigt, sich vorwiegend durch dieselbe Art von
 Informationen auszuzeichnen wie x264's Encodier-Handbuch.
 Beginne deshalb damit,
 <link linkend="menc-feat-x264-encoding-options-intro">den ersten Teil</link>
 dieses Handbuchs zu lesen.
</para>


<sect2 id="menc-feat-xvid-intro">
<title>Welche Optionen sollte ich verwenden, um die besten Resultate zu erzielen?</title>

<para>
 Bitte beginne mit der Durchsicht der
 <systemitem class="library">XviD</systemitem>-Sektion von
 <application>MPlayer</application>s Manpage.
 Diese Sektion ist als Ergänzung zur Manpage zu verstehen.
</para>
<para>
 Die Standardeinstellungen von XviD sind bereits ein guter Kompromiss zwischen
 Geschwindigkeit und Qualität, deshalb kannst du ruhig bei ihnen
 bleiben, wenn nachfolgender Abschnitt dich allzusehr ins Grübeln bringt.
</para>
</sect2>

<sect2 id="menc-feat-xvid-encoding-options">
<title>Encodieroptionen von <systemitem class="library">XviD</systemitem></title>

<itemizedlist>
<listitem><para>
 <emphasis role="bold">vhq</emphasis>
  Diese Einstellung betreffen den Entscheidungsalgorithmus für
  Macroblöcke, wobei gilt, je höher die Einstellung desto weiser die
  Entscheidung.
  Die Standardeinstellung kann für jede Encodierung sicher verwendet
  werden, während höhere Einstellungen immer für PSNR hilfreich, jedoch
  signifikant langsamer sind.
  Nimm bitte zur Kenntnis, dass ein besserer PSNR nicht notwedigerweise
  bedeutet, dass das Bild besser aussehen wird, aber er zeigt dir, dass
  du näher am Original bist.
  Wird er deaktiviert, beschleunigt dies die Encodierung spürbar; wenn
  Geschwindigkeit ein Kriterium für dich ist, kann dieser Kompromiss es wert sein.
</para></listitem>

<listitem><para>
 <emphasis role="bold">bvhq</emphasis>
  Dies erledigt dieselbe Arbeit wie vhq, macht dies jedoch bei B-Frames.
  Es hat einen vernachlässigbar kleinen Einfluss auf die Geschwindigkeit, und
  verbessert geringfügig die Qualität (um etwa +0.1dB PSNR).
</para></listitem>

<listitem><para>
 <emphasis role="bold">max_bframes</emphasis>
  Eine höhere Anzahl von erlaubten hintereinander folgenden B-frames verbessert
  gewöhnlich die Komprimierbarkeit, obwohl dies auch zu mehr Blockartefakten
  führt.
  Die Standardeinstellung ist ein guter Kompromiss zwischen Komprimierbarkeit
  und Qualität, aber wenn du Bitraten-hungrig bist kannst du sie bis auf 3
  hochschrauben.
  Du kannst sie auch auf 1 oder 0 verringern, wenn du auf perfekte Qualität
  abzielst, wenngleich du in diesem Fall sicherstellen solltest, dass deine
  Zielbitrate hoch genug ist, um zu gewährleisten, dass der Encoder nicht
  die Quantisierer höher setzen muss, um den Wert zu erreichen.
</para></listitem>

<listitem><para>
 <emphasis role="bold">bf_threshold</emphasis>
  Dies kontrolliert die B-Frame-Empfindlichkeit des Encoders, wobei ein
  höherer Wert dazu führt, dass mehr B-Frames angewendet werden (und
  umgekehrt).
  Diese Einstellung muss zusammen mit <option>max_bframes</option>
  verwendet werden; bist du Bitraten-hungrig, solltest du beides erhöhen,
  <option>max_bframes</option> und <option>bf_threshold</option>,
  während du <option>max_bframes</option> erhöhen und
  <option>bf_threshold</option> verringern kannst, sodass der Encoder
  B-Frames nur an Stellen anwendet, die diese auch
  <emphasis role="bold">wirklich</emphasis> brauchen.
  Eine niedrigere Zahl an <option>max_bframes</option> und ein höherer Wert
  bei <option>bf_threshold</option> ist möglicherweise keine kluge Wahl,
  da dies den Encoder zwingt, B-Frames in Stellen zu setzen, die nicht
  davon profitieren würden und dies daher die visuelle Qualität reduziert.
  Wie auch immer, wenn du mit Standalone-Playern kompatibel bleiben musst,
  die nur alte DivX-Profile unterstützen (der wiederum höchstens einen
  aufeinander folgenden B-Frame unterstützt), wäre dies dein einziger Weg,
  die Komprimierbarkeit mittels B-Frames zu verbessern.
</para></listitem>

<listitem><para>
 <emphasis role="bold">trellis</emphasis>
  Optimiert den Quantisierungsprozess um einen optimalen Kompromiss
  zwischen PSNR und Bitrate zu erhalten, was signifikant Bit-sparend
  wirkt.
  Diese Bits können woanders im Video wieder verwendet werden
  und verbessern die visuelle Gesamtqualität.
  Du solltest es immer eingeschaltet lassen, da sein Einfluss auf
  die Qualität gewaltig ist.
  Gerade wenn du Geschwindigkeit haben willst, darfst du es nicht
  deaktivieren, solange du nicht <option>vhq</option>
  und alle anderen CPU-hungrigeren Optionen auf
  ein Minimum heruntergesetzt hast.
</para></listitem>

<listitem><para>
  <emphasis role="bold">hq_ac</emphasis>
  Aktiviert die Vorhersagemethode für einen besseren Koeffizientenaufwand, was
  die Dateigröße leicht um etwa 0.15 bis 0.19% reduziert (was mit einer
  PSNR-Erhöhung um weniger als 0.01dB einhergeht), während es eine
  vernachlässigbar kleine Einwirkung auf die Geschwindigkeit hat.
  Es empfiehlt sich deshalb, dies immer eingeschaltet zu lassen.
</para></listitem>

<listitem><para>
 <emphasis role="bold">cartoon</emphasis>
  Entworfen, um Kartoon-Inhalt besser zu encodieren, und hat keine Auswirkung
  auf die Geschwindigkeit, da es lediglich die Heuristiken zur Bestimmung des
  Modus für diese Art Inhalt abstimmt.
</para></listitem>

<listitem><para>
 <emphasis role="bold">me_quality</emphasis>
  Diese Einstellung ist da, um die Präzision der Bewegungseinschätzung zu
  kontrollieren.
  Je höher <option>me_quality</option>, desto präziser wird die Schätzung
  der Originalbewegung sein, und desto besser wird der resultierende Ausschnitt
  die Originalbewegung einfangen.
 </para>
 <para>
  Die Standardeinstellung ist in jedem Fall die beste;
  folglich ist es nicht empfehlenswert, sie herunter zu drehen,
  es sei denn du hast es wirklich auf Geschwindigkeit abgesehen,
  da alle durch eine gute Bewegungseinschätzung gesparten Bits
  woanders verwendet würden, was die Gesamtqualität verbessern
  würde.
  Gehe deshalb nie unter 5, selbst wenn es der letzte Ausweg
  sein sollte.
</para></listitem>

<listitem><para>
 <emphasis role="bold">chroma_me</emphasis>
  Verbessert die Bewegungsabschätzung dadurch, dass auch die
  chroma-(Farb)-Informationen einbezogen werden, wobei
  <option>me_quality</option> alleine nur luma (Graustufen)
  verwendet.
  Dies verlangsamt die Encodierung um 5-10%, verbessert aber die
  visuelle Qualität durch Reduzieren von Blockeffekten ein wenig
  und reduziert die Dateigröße um rund 1.3%.
  Wenn du Geschwindigkeit haben willst, solltest du diese Option
  deaktivieren, bevor du anfängst zu überlegen,
  <option>me_quality</option> zu reduzieren.
</para></listitem>

<listitem><para>
  <emphasis role="bold">chroma_opt</emphasis>
    Ist dafür vorgesehen, die chroma-Bildqualität rund um reine
    weiße/schwarze Kanten zu verbessern, eher noch als die
    Kompression zu verbessern.
    Dies kann dabei helfen, den &quot;Rote Stufen&quot;-Effekt zu reduzieren.
</para></listitem>

<listitem><para>
  <emphasis role="bold">lumi_mask</emphasis>
    Versucht, weniger Bitrate auf den Teil eines Bildes zu übergeben,
    der vom menschlichen Auge nicht gut zu sehen ist, was dem Encoder
    erlauben sollte, die eingesparten Bits auf wichtigere Teile des
    Bildes anzuwenden.
    Die durch diese Option gewonnene Encodierungsqualität hängt in
    hohem Maße von persönlichen Vorlieben und von Monitortyp und
    dessen Einstellungen ab (typischerweise wird es nicht gut aussehen,
    wenn er hell oder ein TFT-Monitor ist).
</para></listitem>

<listitem><para>
  <emphasis role="bold">qpel</emphasis>
    Hebt die Anzahl Kandidaten der Bewegungsvektoren durch
    Erhöhung der Präzision der Bewegungsabschätzung von einem
    halben Pixel (halfpel) auf ein viertel Pixel
    (quarterpel) an.
    Die Idee dahinter ist, bessere Bewegungsvektoren zu finden,
    was wiederum die Bitrate reduziert (deshalb wird die Qualität
    verbessert).
    Bewegungsvektoren mit viertel Pixel Präzision brauchen ein
    paar Extrabits für die Codierung, die Bewegungsvektoren ergeben aber
    nicht immer ein (viel) besseres Resultat.
    Sehr oft verbraucht der Codec dennoch Bits für die Extrapräzision,
    jedoch wird im Gegenzug eine geringe oder keine Extraqualität
    gewonnen.
    Unglücklicherweise gibt es keinen Weg, den möglichen Gewinn von
    <option>qpel</option> vorzuaussagen, also musst du eigentlich
    mit und ohne encodieren, um sicher zu gehen.
  </para><para>
    <option>qpel</option> kann fast die doppelte Encodierzeit in
    Anspruch nehmen und erfordert etwa 25% mehr
    Verarbeitungsleistung fürs Decodieren.
    Es wird nicht von allen Standalone-Playern unterstützt.
</para></listitem>

<listitem><para>
  <emphasis role="bold">gmc</emphasis>
    Versucht, Bits beim Schwenken von Szenen einzusparen, indem es einen
    einzelnen Bewegungsvektor für den gesamten Frame verwendet.
    Dies erhöht fast immer den PSNR, verlangsamt aber signifikant
    die Encodierung (genauso wie die Decodierung).
    Deshalb solltest du es nur nutzen, wenn du <option>vhq</option>
    auf das Maximum gestellt hast.
    <systemitem class="library">XviD</systemitem>s GMC ist höher
    entwickelt als das von DivX, wird aber nur von ein paar
    Standalone-Playern unterstützt.
</para></listitem>

</itemizedlist>
</sect2>

<sect2 id="menc-feat-xvid-encoding-profiles">
<title>Encodierung Profile</title>
<para>
  XviD unterstützt Encodierungsprofile über die Option <option>profile</option>,
  die dazu verwendet werden, den Eigenschaften des XviD-Videostreams
  Restriktionen so aufzuerlegen, dass es überall dort abgespielt werden kann,
  wo das gewählte Profil unterstützt wird.
  Die Restriktionen beziehen sich auf Auflösungen, Bitraten und
  bestimmte MPEG-4-Features.
  Die folgende Tabelle zeigt, was jedes Profil unterstützt.
</para>
<informaltable>
<tgroup cols="16" align="center">
<colspec colnum="1"  colname="col1"/>
<colspec colnum="2"  colname="col2"/>
<colspec colnum="3"  colname="col3"/>
<colspec colnum="4"  colname="col4"/>
<colspec colnum="5"  colname="col5"/>
<colspec colnum="6"  colname="col6"/>
<colspec colnum="7"  colname="col7"/>
<colspec colnum="8"  colname="col8"/>
<colspec colnum="9"  colname="col9"/>
<colspec colnum="10" colname="col10"/>
<colspec colnum="11" colname="col11"/>
<colspec colnum="12" colname="col12"/>
<colspec colnum="13" colname="col13"/>
<colspec colnum="14" colname="col14"/>
<colspec colnum="15" colname="col15"/>
<colspec colnum="16" colname="col16"/>
<colspec colnum="17" colname="col17"/>
<spanspec spanname="spa2-5"   namest="col2" nameend="col5"/>
<spanspec spanname="spa6-11"  namest="col6" nameend="col11"/>
<spanspec spanname="spa12-17" namest="col12" nameend="col17"/>
  <tbody>
    <row>
      <entry></entry>
      <entry spanname="spa2-5">Einfach</entry>
      <entry spanname="spa6-11">Einfach erweitert</entry>
      <entry spanname="spa12-17">DivX</entry>
    </row>
    <row>
      <entry>Profilname</entry>
      <entry>0</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>3</entry>
      <entry>0</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>3</entry>
      <entry>4</entry>
      <entry>5</entry>
      <entry>Handheld</entry>
      <entry>Portable NTSC</entry>
      <entry>Portable PAL</entry>
      <entry>Home Theater NTSC</entry>
      <entry>Home Theater PAL</entry>
      <entry>HDTV</entry>
    </row>
    <row>
      <entry>Breite [Pixel]</entry>
      <entry>176</entry>
      <entry>176</entry>
      <entry>352</entry>
      <entry>352</entry>
      <entry>176</entry>
      <entry>176</entry>
      <entry>352</entry>
      <entry>352</entry>
      <entry>352</entry>
      <entry>720</entry>
      <entry>176</entry>
      <entry>352</entry>
      <entry>352</entry>
      <entry>720</entry>
      <entry>720</entry>
      <entry>1280</entry>
    </row>
    <row>
      <entry>Höhe [Pixel]</entry>
      <entry>144</entry>
      <entry>144</entry>
      <entry>288</entry>
      <entry>288</entry>
      <entry>144</entry>
      <entry>144</entry>
      <entry>288</entry>
      <entry>288</entry>
      <entry>576</entry>
      <entry>576</entry>
      <entry>144</entry>
      <entry>240</entry>
      <entry>288</entry>
      <entry>480</entry>
      <entry>576</entry>
      <entry>720</entry>
    </row>
    <row>
      <entry>Framerate [fps]</entry>
      <entry>15</entry>
      <entry>15</entry>
      <entry>15</entry>
      <entry>15</entry>
      <entry>30</entry>
      <entry>30</entry>
      <entry>15</entry>
      <entry>30</entry>
      <entry>30</entry>
      <entry>30</entry>
      <entry>15</entry>
      <entry>30</entry>
      <entry>25</entry>
      <entry>30</entry>
      <entry>25</entry>
      <entry>30</entry>
    </row>
    <row>
      <entry>Max. mittlere Bitrate [kbps]</entry>
      <entry>64</entry>
      <entry>64</entry>
      <entry>128</entry>
      <entry>384</entry>
      <entry>128</entry>
      <entry>128</entry>
      <entry>384</entry>
      <entry>768</entry>
      <entry>3000</entry>
      <entry>8000</entry>
      <entry>537.6</entry>
      <entry>4854</entry>
      <entry>4854</entry>
      <entry>4854</entry>
      <entry>4854</entry>
      <entry>9708.4</entry>
    </row>
    <row>
      <entry>Höchstwert mittlere Bitrate über 3 Sek. [kbps]</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>800</entry>
      <entry>8000</entry>
      <entry>8000</entry>
      <entry>8000</entry>
      <entry>8000</entry>
      <entry>16000</entry>
    </row>
    <row>
      <entry>Max. B-Frames</entry>
      <entry>0</entry>
      <entry>0</entry>
      <entry>0</entry>
      <entry>0</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>0</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>2</entry>
    </row>
    <row>
      <entry>MPEG-Quantisierung</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry>Adaptive Quantisierung</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
    </row>
    <row>
      <entry>Interlaced Encodierung</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
    </row>
    <row>
      <entry>Viertelpixel</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
    <row>
      <entry>Globale Bewegungskompensierung</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry>X</entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
      <entry></entry>
    </row>
  </tbody>
</tgroup>
</informaltable>
</sect2>

<sect2 id="menc-feat-xvid-example-settings">
<title>Encodierungseinstellungen Beispiele</title>

<para>
  Die folgenden Einstellungen sind Beispiele unterschiedlicher
  Kombinationen von Encodierungsoptionen, die den Kompromiss
  zwischen Geschwindigkeit gegenüber Qualität bei gleicher
  Zielbitrate betreffen.
</para>

<para>
  Alle Encodierungseinstellungen wurden auf einem Beispielvideo
  mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps,
  und der Rechner war ein
  AMD-64 3400+ mit 2400 Mhz im 64bit-Modus.
  Jede Encodierungseinstellung zeichnet sich aus durch die gemessene
  Encodiergeschwindigkeit (in Frames pro Sekunde) und den PSNR-Verlust
  (in dB) im Vergleich zu Einstellungen für &quot;sehr hohe Qualität&quot;.
  Bitte hab Verständnis, dass du abhängig von deiner Quelldatei,
  deinem Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche
  Resultate erzielen wirst.
</para>

<para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row><entry>Beschreibung</entry><entry>Encodieroptionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
</thead>
<tbody>
<row>
  <entry>Sehr hohe Qualität</entry>
  <entry><option>chroma_opt:vhq=4:bvhq=1:quant_type=mpeg</option></entry>
  <entry>16fps</entry>
  <entry>0dB</entry>
</row>
<row>
  <entry>Hohe Qualität</entry>
  <entry><option>vhq=2:bvhq=1:chroma_opt:quant_type=mpeg</option></entry>
  <entry>18fps</entry>
  <entry>-0.1dB</entry>
</row>
<row>
  <entry>Schnell</entry>
  <entry><option>turbo:vhq=0</option></entry>
  <entry>28fps</entry>
  <entry>-0.69dB</entry>
</row>
<row>
  <entry>Echtzeit</entry>
  <entry><option>turbo:nochroma_me:notrellis:max_bframes=0:vhq=0</option></entry>
  <entry>38fps</entry>
  <entry>-1.48dB</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

</sect1>

<sect1 id="menc-feat-x264">
<title>Encodieren mit dem <systemitem class="library">x264</systemitem>-Codec</title>
<para>
  <systemitem class="library">x264</systemitem> ist eine freie
  Programmbibliothek zum Encodieren von H.264/AVC-Videostreams.
  Bevor du mit <link linkend="xvid"> zu encodieren beginnst, musst du
 <application>MEncoder</application> so einstellen, dass er es unterstützt</link>.
</para>

<sect2 id="menc-feat-x264-encoding-options">
<title>Encodieroptionen von x264</title>

<para>
  Bitte beginne mit der Durchsicht der
  <systemitem class="library">x264</systemitem>-Sektion von
  <application>MPlayer</application>s Manpage.
  Diese Sektion ist als Anhang zur Manpage vorgesehen.
  Hier wirst du Schnellhinweise dazu finden, welche Optionen am
  wahrscheinlichsten die meisten Leute interessieren. Die Manpage
  ist knapper gehalten, aber auch vollständiger, und zeigt oft
  viel bessere technische Details.
</para>

<sect3 id="menc-feat-x264-encoding-options-intro">
<title>Einführung</title>
<para>Dieses Handbuch berücksichtigt zwei Hauptkategorien der Encodieroptionen:</para>

<orderedlist>
  <listitem><para>Optionen, die hauptsächlich Encodierdauer gegenüber Qualität
  abwägen
  </para></listitem>
  <listitem><para>Optionen, die zur Erfüllung zahlreicher persönlicher
  Vorlieben und spezieller Anforderungen nützlich sind</para></listitem>
</orderedlist>

<para>
  Letztendlich kannst nur du entscheiden, welche Optionen für deine
  Zwecke am besten geeignet sind. Die Entscheidung für die erste
  Klasse der Optionen ist die einfachste:
  Du musst nur entscheiden, ob du denkst, dass Qualitätsunterschiede
  Geschwindigkeitsunterschiede rechtfertigen. Für die zweite Klasse
  der Optionen sind die Vorzüge weitaus subjektiver, und mehr Faktoren
  können involviert sein. Beachte, dass manche der Optionen für
  &quot;persönliche Vorlieben und spezielle Anforderungen&quot;
  noch große Auswirkungen auf Geschwindigkeit oder Qualität haben können,
  das ist aber nicht, wozu sie primär benutzt werden. Ein paar der
  Optionen für &quot;persönliche Vorlieben&quot; können sogar Änderungen
  verursachen, die für manche Leute besser aussehen aber schlechter
  für andere.
</para>

<para>
  Bevor du fortfährst, musst du verstehen, dass dieses Handbuch nur
  eine Qualitätsmetrik verwendet: globaler PSNR.
  Für eine kurze Erklärung, was PSNR ist, schau dir
  <ulink url="http://en.wikipedia.org/wiki/PSNR">den Wikipedia-Artikel zu PSNR</ulink>
  an.
  Globaler PSNR ist die letzte gemeldete PSNR-Nummer, wenn du die
  Option <option>psnr</option> in <option>x264encopts</option>
  einbindest.
  Jedesmal wenn du eine Forderung nach PSNR liest, ist eine der Annahmen
  hinter dieser Forderung, dass gleiche Bitraten verwendet werden.
</para>

<para>
  Nahezu alle dieser Handbuchkommentare unterstellen, dass du
  2-pass anwendest.
  Beim Vergleich der Optionen gibt es zwei Hauptgründe, 2-pass-Encodierung
  zu nutzen.
  Der erste ist, 2-pass bringt rund 1dB PSNR, was einen sehr
  großen Unterschied ausmacht.
  Der zweite ist, Optionen zu testen, indem man direkte Qualitätsvergleiche
  zu 1-pass-Encodierung anstellt, führt einen einen wichtigen verwirrenden
  Faktor ein: die Bitrate variiert bei jeder Encodierung oft signifikant.
  Es ist nicht immer einfach zu sagen, ob Qualitätsänderungen vorwiegend
  auf geänderte Optionen zurückzuführen sind oder ob sie meist
  essentielle, zufällige Unterschiede in der erhaltenen Bitrate reflektieren.
</para>

</sect3>

<sect3 id="menc-feat-x264-encoding-options-speedvquality">
<title>Optionen die primär Geschwindigkeit und Qualität betreffen</title>

<itemizedlist>
<listitem><para>
  <emphasis role="bold">subq</emphasis>:
  Von den Optionen, die dir erlauben, einen Kompromiss zwischen
  Geschwindigkeit und Qualität einzugehen, sind <option>subq</option>
  und <option>frameref</option> (siehe unten) gewöhnlich die bei weitem
  wichtigsten.
  Wenn du dich für die Optimierung von entweder Geschwindigkeit oder Qualität
  interessierst, sind diese die ersten, die du in Erwägung ziehen solltest.
  Bei der Dimension Geschwindigkeit, interagieren die Optionen
  <option>frameref</option> und <option>subq</option> ziemlich stark
  miteinander.
  Die Erfahrung zeigt, dass mit einem Referenzframe <option>subq=5</option>
  (die Standardeinstellung) das ganze etwa 35% mehr Zeit in Anspruch nimmt als
  <option>subq=1</option>.
  Mit 6 Referenzframes wächst der Nachteil auf 60%.
  Der Effekt, den <option>subq</option> auf den PSNR ausübt, scheint ziemlich
  konstant zu sein, ungeachtet der Anzahl der Referenzframes.
  Typischerweise erreicht <option>subq=5</option> einen 0.2-0.5 dB höheren globalen
  PSNR im Vergleich zu <option>subq=1</option>.
  Dies ist gewöhnlich ausreichend, um sichtbar zu werden.
</para>
<para>
  <option>subq=6</option> ist der langsamste Modus mit der höchsten
  Qualität.
  Im Vergleich zu <option>subq=5</option> gewinnt sie gewöhnlich 0.1-0.4 dB
  globalen PSNR mit Geschwindigkeitseinbußen, die sich zwischen 25%-100%
  bewegen.
  Im Unterschied zu anderen Levels von <option>subq</option> hängt das
  Verhalten von <option>subq=6</option> nicht sehr von <option>frameref</option>
  und <option>me</option> ab.  Statt dessen hängt die Effektivität von
  <option>subq=6</option> größtenteils von der Anzahl der verwendeten
  B-Frames ab. Im Normalgebrauch bedeutet dies, <option>subq=6</option>
  hat einen großen Einfluss auf Geschwindigkeit und Qualität
  in komplexen, stark bewegten Szenen, kann aber auch einen geringen Effekt
  in Szenen mit wenig Bewegung haben. Beachte, dass dennoch empfohlen wird,
  <option>bframes</option> immer auf etwas anderes als null
  zu setzen (siehe unten).
</para></listitem>
<listitem><para>
  <emphasis role="bold">frameref</emphasis>:
  <option>frameref</option> ist per Voreinstellung auf 1 gesetzt, jedoch
  solltest du deshalb nicht darauf schließen, dass es unbedingt
  auf 1 gesetzt sein muss.
  Allein die Erhöhung von <option>frameref</option> auf 2 bringt rund
  0.15dB PSNR mit einem Geschwindigkeitsnachteil von 5-10%; dies sieht nach
  einem guten Kompromiss aus.
  <option>frameref=3</option> bringt rund 0.25dB PSNR mehr als
  <option>frameref=1</option>, was einen sichtbaren Unterschied machen
  sollte.
  <option>frameref=3</option> ist rund 15% langsamer als
  <option>frameref=1</option>.
  Leider setzen vermindernde Rückgaben schnell ein.
  <option>frameref=6</option> kann erwartungsgemäß nur
  0.05-0.1 dB mehr als <option>frameref=3</option> bei zusätzlichen
  15% Geschwindigkeitsnachteil.
  Oberhalb <option>frameref=6</option> sind die Qualitätsgewinne
  für gewöhnlich sehr klein (obwohl du während der ganzen Diskussion
  im Kopf behalten solltest, dass sie abhängig von deiner Quelle stark
  variieren können).
  In einem ziemlich typischen Fall wird <option>frameref=12</option>
  den globalen PSNR um ein bisschen mehr als 0.02dB gegenüber
  <option>frameref=6</option> verbessern, bei Geschwindigkeitseinbußen
  von 15%-20%.
  Bei so hohen <option>frameref</option>-Werten ist das wirklich
  einzig Gute, dass man sagen kann, dass ein weiteres Anheben dieses
  Wertes ziemlich sicher nie den PSNR <emphasis role="bold">schädigen</emphasis>
  wird, jedoch sind zusätzliche Qualitätsvorteile sogar kaum messbar,
  geschweige denn wahrnehmbar.
</para>
<note><title>Beachte:</title>
<para>
  Das Erhöhen von <option>frameref</option> auf unnötig hohe Werte
  <emphasis role="bold">kann</emphasis> und
  <emphasis role="bold">tut dies üblicherweise auch</emphasis>
  die Codiereffizienz schädigen, wenn du CABAC ausschaltest.
  Mit eingeschaltetem CABAC (das Standardverhalten) scheint die
  Möglichkeit, <option>frameref</option> &quot;zu hoch&quot;
  zu setzen, gegenwärtig zu weit entfernt um sich Sorgen zu machen,
  und in der Zukunft werden womöglich Optimierungen diese Möglichkeit
  ganz und gar ausschließen.
</para>
</note>
<para>
  Wenn du auf Geschwindigkeit abzielst, ist ein vernünftiger
  Kompromiss, im ersten Durchgang niedrigere <option>subq</option>- und
  <option>frameref</option>-Werte zu nehmen, und sie danach im
  zweten Durchgang zu erhöhen.
  Typischerweise hat dies einen vernachlässigbar negativen Effekt
  auf die Encodierqualität: Du wirst womöglich unter 0.1dB PSNR
  verlieren, was viel zu klein für einen sichtbaren Unterschied
  sein sollte.
  Trotzdem, unterschiedliche Werte für <option>frameref</option>
  können auf verschiedene Weise die Frametypenbestimmung beeinflussen.
  Höchstwahrscheinlich sind dies außerordentlich seltene Fälle,
  willst du jedoch wirklich sicher gehen, ziehe in Betracht, ob
  dein Video entweder Vollbild- respektive Einblendungsmuster
  oder sehr große temporäre Überdeckungen enthält, was einen I-Frame
  erzwingen könnte.
  Passe <option>frameref</option> des ersten Durchgangs so an,
  dass es groß genug ist, die Dauer des Einblendungszyklus
  (oder der Überdeckungen) zu enthalten.
  Zum Beispiel, wenn die Szene zwischen zwei Bildern über eine
  Zeitspanne von drei Frames rückwärts und vorwärts springt,
  setze <option>frameref</option> des ersten Durchgangs auf 3
  oder höher.
  Dieser Sachverhalt kommt vermutlich extrem selten in
  Videomaterial mit Live Action vor, erscheint aber manchmal
  bei eingefangenen Computerspiel-Sequenzen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">me</emphasis>:
  Diese Option dient der Wahl der Suchmethode der Bewegungseinschätzung.
  Diese Option zu verändern stellt einen überschaubaren Kompromiss
  zwischen Qualität und Geschwindigkeit dar.
  <option>me=1</option> ist nur ein paar Prozent schneller als
  die Standardsuche, auf Kosten von unter 0.1dB globalem PSNR. Die
  Standardeinstellung (<option>me=2</option>) ist ein angemessener
  Kompromiss zwischen Qualität und Geschwindigkeit.
  <option>me=3</option> bringt ein wenig unter 0.1dB globalem PSNR,
  mit Geschwindigkeitsnachteil, der abhängig von <option>frameref</option>
  variiert. Bei hohen <option>frameref</option>-Werten (z.B. 12 oder so)
  ist <option>me=3</option> etwa 40% langsamer als die Standardeinstellung
  <option>me=2</option>. Mit <option>frameref=3</option> fällt der
  Geschwindigkeitsnachteil auf 25%-30%.
</para>
<para>
  <option>me=4</option> verwendet eine gründliche, für die praktische
  Anwendung zu langsame Suche.
</para>
</listitem>

<listitem><para>
  <emphasis role="bold">4x4mv</emphasis>:
  Diese Option aktiviert die Verwendung von 8x4, 4x8 und 4x4 Unterteilungen
  in den vorhergesagten Macroblöcken. Sie zu aktivieren führt zu einem
  recht beständigen Geschwindigkeitsverlust von 10%-15%. Sie ist
  ziemlich nutzlos bei Quellen, die nur langsame Bewegungen enthalten,
  obwohl in manchen Quellen mit sehr viel Bewegung und vielen kleinen,
  sich bewegenden Objekten Zugewinne von etwa 0.1dB erwartet werden können.
</para>
</listitem>

<listitem><para>
  <emphasis role="bold">bframes</emphasis>:
  Wenn du gewohnt bist, mit anderen Codecs zu encodieren, hast du
  womöglich empfunden, dass B-Frames nicht immer nützlich sind.
  Bei H.264 wurde dies geändert: es gibt neue Techniken und Blocktypen,
  die in B-Frames möglich sind.
  Für gewöhnlich kann selbst ein einfältiger Algorithmus zur Wahl
  der B-Frames einen signifikanten PSNR-Vorteil bringen.
  Es ist interessant festzustellen, dass die Anwendung von B-Frames
  normalerweise den zweiten Durchgang ein bisschen beschleunigt,
  und er kann auch eine Encodierung mit einfachem Durchgang etwas
  schneller machen, wenn adaptive B-Frame-Bestimmung deaktiviert
  ist.
</para>
<para>
  Mit deaktivierter adaptiver B-Framebestimmung
  (<option>nob_adapt</option> von <option>x264encopts</option>)
  ist der optimale Wert für diese Einstellung normalerweise nicht
  mehr als <option>bframes=1</option>, andernfalls leiden Szenen
  mit sehr viel Bewegung darunter.
  Mit aktivierter adaptiver B-Framebestimmung (das Standardverhalten)
  ist es sicher, höhere Werte zu verwenden; der Encoder wird die Anwendung
  von B-Frames in Szenen reduzieren, in denen sie die Kompression
  schädigen könnten.
  Der Encoder zieht es selten vor, mehr als 3 oder 4 B-Frames zu
  verwenden; diese Option höher zu setzen wird einen geringen Effekt haben.
</para></listitem>

<listitem><para>
  <emphasis role="bold">b_adapt</emphasis>:
  Beachte: Dies ist standardmäßig eingeschaltet.
</para>
<para>
  Ist diese Option aktiviert, wird der Encoder einen einigermaßen schnellen
  Entscheidungsprozess zur Reduzierung der Anzahl B-Frames in Szenen anwenden, die
  nicht viel von ihnen profitieren würden.
  Du kannst <option>b_bias</option> dazu verwenden, zu optimieren wie
  froh der Encoder über B-Frames sein soll.
  Der Geschwindigkeitsnachteil adaptiver B-Frames ist gegenwärtig ziemlich
  bescheiden, und genauso ist der potentielle Qualitätsgewinn.
  Es sollte aber normalerweise nicht schaden.
  Beachte, dass dies nur Geschwindigkeit und Frametypenbestimmung im ersten
  Durchgang betrifft.
  <option>b_adapt</option> und <option>b_bias</option> haben keinen
  Effekt auf nachfolgende Durchgänge.
</para></listitem>

<listitem><para>
  <emphasis role="bold">b_pyramid</emphasis>:
  Du kannst diese Option genauso gut aktivieren, falls du >=2 B-Frames
  verwendest; wie die Manpage dir sagt, erreichst du eine kleine
  Qualitätsverbesserung bei keinerlei Geschwindigkeitseinbuße.
  Beachte, dass diese Videos von libavcodec-basierten Decodern
  älter als etwa 5. März 2005 nicht gelesen werden können.
</para></listitem>

<listitem><para>
  <emphasis role="bold">weight_b</emphasis>:
  In typischen Fällen gibt es nicht viel Gewinn mit dieser Option.
  Trotzdem, in überblendenden oder ins Schwarze übergehenden Szenen
  liefert die gewichtete Vorhersage ziemlich große Einsparungen bei der Bitrate.
  In MPEG-4 ASP wird ein Übergang ins Schwarze gewöhnlich am besten
  als eine Serie aufwändiger I-Frames codiert; das Verwenden einer
  gewichteten Vorhersage in B-Frames macht es möglich, wenigstens
  manche von diesen in viel kleinere B-Frames zu wandeln.
  Der Verlust an Encodierzeit ist minimal, da keine extra Bestimmungen
  vorgenommen werden müssen.
  Auch werden die CPU-Anforderungen des Encoders, im Gegensatz zu den
  Einschätzungen mancher Leute, von gewichteter Vorhersage nicht sonderlich
  beeinflusst, ansonsten bleibt alles gleich.
</para>
<para>
  Leider hat der aktuelle Algorithmus zur adaptiven B-Frame-Bestimmung
  eine starke Tendenz, B-Frames während des Fadens zu verhindern.
  Bis sich dies ändert, kann es eine gute Idee sein,
  <option>nob_adapt</option> zu deinen x264encopts hinzuzufügen, falls
  du erwartest, dass Fades einen großen Effekt in deinem jeweiligen
  Videoclip erzeugen.
</para></listitem>
</itemizedlist>
</sect3>

<sect3 id="menc-feat-x264-encoding-options-misc-preferences">
<title>Diverse Eigenschaften betreffende Optionen</title>
<itemizedlist>
<listitem><para>
  <emphasis role="bold">2-pass-Encodierung</emphasis>:
  Oben wurde vorgeschlagen, immer 2-pass-Encodierung anzuwenden.
  Es gibt aber durchaus Gründe, dies nicht zu tun. Beispielsweise bist du,
  wenn du Live-TV aufnimmst und in Echtzeit encodierst,
  gezwungen, einen einzigen Durchgang zu verwenden.
  Auch ist ein Durchgang offensichtlich schneller als zwei Durchgänge;
  wenn du exakt die gleichen Optionen bei beiden Durchgängen anwendest,
  ist das Encodieren in zwei Durchgängen mindestens zweimal so langsam.
</para>
<para>
  Noch gibt es sehr gute Gründe, in zwei Durchgängen zu encodieren.
  Zum einen ist Ratenkontrolle in einem Durchgang kein Allheilmittel.
  Sie trifft oft eine unvernünftige Auswahl, weil sie das große
  Bild nicht sehen kann. Zum Beispiel angenommen, du hast ein zwei Minuten
  langes Video bestehend aus zwei ausgeprägten Hälften.  Die erste Hälfte
  besitzt eine 60 Sekunden dauernde Szene mit sehr viel Bewegung, die
  einzeln für sich etwa 2500kbps benötigt, um anständig auszusehen.
  Direkt daruffolgend kommt eine viel weniger anspruchsvolle 60 Sekunden
  lange Szene, die bei 300kbps gut aussieht. Angenommen du forderst in
  der Theorie 1400kbps an, was beiden Szenen ausreichend entgegenkommen
  würde. Die Ratenkontrolle in einem Durchgang wird in diesem Fall
  ein paar &quot;Fehler&quot; machen. Zuallererst wird es in beiden Segmenten
  1400kbps anpeilen. Das erste Segment könnte schwer überquantisiert enden,
  was es unakzeptabel und unangemessen blockhaft aussehen lässt.
  Das zweite Segment wird schwer unterquantisiert sein; es sieht vielleicht
  perfekt aus, aber der Bitratenverlust dieser Perfektion wird komplett
  unangemessen sein.
  Noch schwerer vermeidbar ist das Problem am Übergang beider Szenen.
  Die ersten Sekunden der Hälfte mit wenig Bewegung wird enorm
  überquantisiert sein, weil die Ratenkontrolle noch die Art Anforderung
  an die Bitrate erwartet, der sie in der ersten Hälfte des Videos begegnet
  war. Diese &quot;Fehlerperiode&quot; der extrem überquantisierten Szene
  mit wenig Bewegung wird fürchterlich schlecht aussehen, und wird sogar
  weniger als die 300kbps in Anspruch nehmen als das, was sie genommen hätte, um annehmbar
  auszusehen. Es gibt Mittel und Wege, diese Fälle des Encodierens in einem
  Durchgang zu mildern, diese werden allerdingst dahin tendieren, die
  fehlerhaften Vorhersagen der Bitraten zu häufen.
</para>
<para>
  Multipass-Ratenkontrolle kann gegenüber der eines einzigen Durchgangs
  enorm große Vorteile bieten.
  Indem sie die im ersten Encodierungsdurchlauf gesammelte Statistik
  verwendet, kann der Encoder mit angemessener Genauigkeit den Aufwand
  (in Bit) abschätzen, den das Encodieren jeden gegebenen Frames bei
  jedem gegebenen Quantisierer erfordert. Dies erlaubt eine viel
  rationalere, besser geplante Zuweisung von Bits zwischen den
  bithungrigen Szenen mit viel Bewegung und denen bescheidenen mit
  wenig Bewegung.
  Siehe <option>qcomp</option> unten für einige Ideen darüber, wie man
  diese Zuweisungen nach seinem Geschmack optimiert.
</para>
<para>
  Darüber hinaus brauchen zwei Durchgänge zweimal so lang wie ein Durchgang.
  Du kannst die Optionen im ersten Durchgang auf höhere Geschwindigkeit
  und niedrigere Qualität optimieren.
  Wenn du deine Optionen geschickt wählst, kannst du einen sehr schnellen
  ersten Durchgang hinkriegen.
  Die resultierende Qualität im zweiten Durchgang wird geringfügig niedriger
  ausfallen, weil die Größenvorhersage weniger akkurat ist, jedoch
  ist die Qualitätsdifferenz normalerweise viel zu klein, um sichtbar zu sein.
  Versuche zum Beispiel <option>subq=1:frameref=1</option> zu
  <option>x264encopts</option> des ersten Durchgangs hinzuzufügen.
  Verwende dann im zweiten Durchgang langsamere, hochwertigere Optionen:
  <option>subq=6:frameref=15:4x4mv:me=3</option>
</para></listitem>
<listitem><para>
  <emphasis role="bold">Encodierung mit drei Durchgängen</emphasis>?

  x264 bietet die Möglichkeit, eine beliebige Anzahl aufeinander folgender
  Durchgänge auszuführen. Wenn du <option>pass=1</option> im ersten Durchgang
  spezifizierst, dann verwende <option>pass=3</option> im nachfolgenden
  Durchgang, der nachfolgende Durchgang wird beides tun, die Statistik des
  vorhergehenden Durchgangs lesen und seine eigene Statistik schreiben.
  Ein zusätzlicher Durchgang, der diesem folgt, wird eine sehr gute Basis
  haben, von der aus er hochpräzise Vorhersagen der Framegrößen bei
  einem gewählten Quantisierer machen kann.
  In der Praxis ist der damit erzielte gesamte Qualitätsgewinn
  gewöhnlich nahezu null, und ziemlich wahrscheinlich resultiert ein dritter
  Durchgang in einem geringfügig schlechteren globalen PSNR als der Durchgang
  davor. In der typischen Anwendung helfen drei Durchgänge, wenn du entweder
  eine schleche Vorhersage der Bitraten oder schlecht aussehende Szenenübergänge
  beim Verwenden nur eines Durchlaufs bekommst.
  Dies passiert mit ziemlicher Wahrscheinlichkeit bei extrem kurzen Clips.
  Ebenso gibt es ein paar Spezialfälle, in denen drei (oder mehr) Durchgänge
  erfahrenen Nutzern dienlich sind, aber um es kurz zu machen, dieses Handbuch
  behandelt die Diskussion solcher speziellen Fälle nicht.
</para></listitem>
<listitem><para>
  <emphasis role="bold">qcomp</emphasis>:
  <option>qcomp</option> wägt die Anzahl der für &quot;aufwändige&quot; Frames
  mit viel Bewegung vorgesehenen Bits gegen die für &quot;weniger aufwändige&quot;
  Frames mit wenig Bewegung ab.
  Bei einem Extrem zielt <option>qcomp=0</option> auf eine echte konstante
  Bitrate ab. Typischerweise würde dies Szenen mit viel Bewegung vollkommen
  ätzend aussehen lassen, während Szenen mit wenig Bewegung womöglich absolut
  perfekt aussehen, jedoch öfter mehr Bitrate verwenden würden, als sie es für
  lediglich sehr gutes Aussehen bräuchten. Beim anderen Extrem
  erreicht <option>qcomp=1</option> nahezu konstante Quantisierungsparameter
  (QP). Ein konstanter QP sieht nicht schlecht aus, die meisten Leute meinen
  aber, es sei vernünftiger, etwas Bitrate aus den extrem aufwändigen Szenen
  zu nehmen (wobei dort der Qualitätsverlust micht ganz so augenfällig ist)
  und sie wieder den Szenen zuzuweisen, die bei sehr guter Qualität leichter
  zu encodieren sind.
  <option>qcomp</option> ist per Voreinstellung auf 0.6 gesetzt, was für den
  Geschmack mancher Leute etwas zu langsam sein könnte (0.7-0.8 werden im
  Allgemeinen auch verwendet).
</para></listitem>
<listitem><para>
  <emphasis role="bold">keyint</emphasis>:
  <option>keyint</option> ist einzig und allein zur Abwägung der
  Durchsuchbarkeit der Datei gegenüber der Codiereffiziez da.
  Als Standardwert ist <option>keyint</option> auf 250 gesetzt. In
  Material mit 25fps garantiert dies, auf 10 Sekunden genau
  suchen zu können. Wenn du meinst, es wäre wichtig und nützlich,
  auf 5 Sekunden genau suchen zu können, setze es auf <option>keyint=125</option>;
  dies wird der Qualität/Bitrate leicht schaden. Wenn es dir nur um Qualität
  geht und nicht um die Durchsuchbarkeit, kannst du viel höhere Werte
  setzen (vorausgesetzt du verstehst, daß es verringerte Resultate gibt, die verschwindend
  klein werden oder sogar gegen null gehen). Der Videostream wird nach
  wie vor suchbare Stellen besitzen, solange einige Szenenwechsel
  vorhanden sind.
</para></listitem>
<listitem><para>
  <emphasis role="bold">deblockalpha, deblockbeta</emphasis>:
  Dieses Thema ist im Begriff etwas kontrovers zu geraten.
</para>
<para>
  H.264 definiert eine simple Deblocking-Prozedur bei I-Blöcken, die
  von vorgegebenen Stärken und vom QP des strittigen Blocks
  abhängigen.
  Mit dem Standardwert werden hohe QP-Blöcke stark gefiltert, und
  niedrige QP-Blöcke werden überhaupt nicht entblockt.
  Die vom Standard definierten vorgegebenen Stärken sind mit
  Bedacht gewählt und die Chancen stehen sehr gut, dass sie
  PSNR-optimal sind, egal welches Video auch immer du zu encodieren
  versuchst.
  Die <option>deblockalpha</option>- und
  <option>deblockbeta</option>-Parameter erlauben dir, Offsets festzulegen,
  um Deblocking-Schwellen voreinzustellen.
</para>
<para>
  Viele Leute scheinen zu glauben, es sei eine gute Idee, die Stärke
  des Deblocking-Filters um hohe Beträge abzusenken (sagen wir -3).
  Dies ist jedoch meist keine gute Idee, und in den meisten Fällen
  verstehen Leute, die das machen, nicht viel davon wie Deblocking
  standardmäßig funktioniert.
</para>
<para>
  Die erste und wichtigste Sache, die man über den
  in-loop-Deblocking-Filter wissen sollte, ist, dass die
  Standardschwellenwerte meistens PSNR-optimal sind.
  In den seltenen Fällen, in denen sie nicht optimal sind, ist das
  ideale Offset plus oder minus 1.
  Die Deblocking-Parameter durch einen höheren Betrag anzupassen
  garantiert meist, dem PSNR zu schaden.
  Das Verstärken des Filters wird mehr Details verwischen; den
  Filter zu schwächen wird das Auftreten von Blockeffekten
  erhöhen.
</para>
<para>
  Es ist definitiv eine schlechte Idee, die Deblocking-Schwellenwerte
  herabzusetzen, falls deine Quelle eine vorwiegend niedrige räumliche
  Komplexität besitzt (z.B. nicht viele Details oder Rauschen).
  Der in-loop-Filter macht eigentlich einen exzellenten Job durch
  das Kaschieren auftretender Artefakte.
  Besitzt die Quelle eine hohe räumliche Komplexität, sind Artefakte
  weniger bemerkbar.
  Dies ist so, weil das Schwingen (ringing) dazu neigt, wie Details
  oder Rauschen auszusehen.
  Die viselle Wahrnehmung des Menschen erkennt leicht, wenn Details
  entfernt wurden, aber erkennt nicht so leicht, wenn Rauschen falsch
  dargestellt wird.
  Wird die Qualität subjektiv, sind Details und Rauschen etwas
  austauschbares.
  Durch das Herabsetzen der Deblocking-Filterstärke verstärkst du
  höchstwahrscheinlich Fehler durch Hinzufügen von
  Schwingungsartefakten, aber dem Auge fällt nichts auf, weil
  es die Artefakte mit Details verwechselt.
</para>

<para>
  Dies rechtfertigt jedoch <emphasis role="bold">nach wie vor</emphasis>
  nicht das Herabsetzen der Deblocking-Filterstärke.
  Du kannst im Allgemeinen besseres Qualitätsrauschen im Postprocessing
  erzielen.
  Falls deine H.264-Encodierungen zu verschwommen oder verschmiert
  aussehen, versuche, mit
  <option>-vf noise</option> beim Abspielen des encodierten Films
  herumzuspielen.
  <option>-vf noise=8a:4a</option> sollte die meisten weichen Artefakte
  kaschieren.
  Es wird meist mit Sicherheit besser aussehen als die Resultate, die
  du durch einfaches Herumtüfteln mit dem Deblocking-Filter bekommen
  hättest.
</para></listitem>
</itemizedlist>
</sect3>
</sect2>

<sect2 id="menc-feat-x264-example-settings">
<title>Beispiele für Encodieroptionen</title>

<para>
  Die folgenden Einstellungen sind Beispiele unterschiedlicher
  Kombinationen von Encodier-Optionen, die einen Kompromiss zwischen
  Geschwindigkeit und Qualität bei gleicher Zielbitrate darstellen.
</para>

<para>
  All diese Encodier-Einstellungen wurden an einem Beispielvideo
  mit 720x448 @30000/1001 fps getestet, die Zielbitrate war 900kbps,
  und der Rechner war ein
  AMD-64 3400+ mit 2400 Mhz im 64bit-Modus.
  Jede Encodier-Einstellung zeichnet sich durch eine gemessene
  Encodiergeschwindigkeit (in Frames pro Sekunde) und dem
  PSNR-Verlust (in dB) im Vergleich zu den &quot;sehr
  hochwertigen&quot; Einstellung aus.
  Bitte hab dafür Verständnis, dass du abhängig von deiner Quelle, deinem
  Rechnertyp und Entwicklungsfortschritten sehr unterschiedliche Resultate
  erhalten kannst.
</para>

<para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row><entry>Beschreibung</entry><entry>Encodier-Optionen</entry><entry>Geschwindigkeit (in fps)</entry><entry>Relativer PSNR-Verlust (in dB)</entry></row>
</thead>
<tbody>
<row>
  <entry>Sehr hohe Qualität</entry>
  <entry><option>subq=6:4x4mv:8x8dct:me=3:frameref=5:bframes=3:b_pyramid:weight_b</option></entry>
  <entry>6fps</entry>
  <entry>0dB</entry>
</row>
<row>
  <entry>Hohe Qualität</entry>
  <entry><option>subq=5:4x4mv:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b</option></entry>
  <entry>13fps</entry>
  <entry>-0.89dB</entry>
</row>
<row>
  <entry>Schnell</entry>
  <entry><option>subq=4:bframes=2:b_pyramid:weight_b</option></entry>
  <entry>17fps</entry>
  <entry>-1.48dB</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

</sect1>

<sect1 id="menc-feat-video-for-windows">
<title>Encodieren mit der <systemitem class="library">Video for Windows</systemitem> Codecfamilie</title>

<para>
  Video for Windows bietet einfaches Encodieren mittels binärer Video-Codecs.
  Du kannst mit folgenden Codecs encodieren (solltest du mehr haben, teile es
  uns bitte mit!)
</para>
<para>
  Beachte, dass der Support hierfür sehr experimentell ist, und
  einige Codecs arbeiten vielleicht nicht korrekt. Manche Codecs werden
  nur in bestimmten Farbräumen funktionieren, versuche
  <option>-vf format=bgr24</option> und <option>-vf format=yuy2</option>,
  falls ein Codec versagt oder einen falschen Output liefert.
</para>

<sect2 id="menc-feat-enc-vfw-video-codecs">
<title>Von Video for Windows unterstützte Codecs</title>

<para>
<informaltable frame="all">
<tgroup cols="4">
<thead>
<row>
<entry>Video-Codec Dateiname</entry>
<entry>Beschreibung (FourCC)</entry>
<entry>md5sum</entry>
<entry>Kommentar</entry>
</row>
</thead>
<tbody>
<row>
  <entry>aslcodec_vfw.dll</entry>
  <entry>Alparysoft verlustfreier (lossless) Codec vfw (ASLC)</entry>
  <entry>608af234a6ea4d90cdc7246af5f3f29a</entry>
  <entry></entry>
</row>
<row>
  <entry>avimszh.dll</entry>
  <entry>AVImszh (MSZH)</entry>
  <entry>253118fe1eedea04a95ed6e5f4c28878</entry>
  <entry>needs <option>-vf format</option></entry>
</row>
<row>
  <entry>avizlib.dll</entry>
  <entry>AVIzlib (ZLIB)</entry>
  <entry>2f1cc76bbcf6d77d40d0e23392fa8eda</entry>
  <entry></entry>
</row>
<row>
  <entry>divx.dll</entry>
  <entry>DivX4Windows-VFW</entry>
  <entry>acf35b2fc004a89c829531555d73f1e6</entry>
  <entry></entry>
</row>
<row>
  <entry>huffyuv.dll</entry>
  <entry>HuffYUV verlustfrei (lossless) (HFYU)</entry>
  <entry>b74695b50230be4a6ef2c4293a58ac3b</entry>
  <entry></entry>
</row>
<row>
  <entry>iccvid.dll</entry>
  <entry>Cinepak Video (cvid)</entry>
  <entry>cb3b7ee47ba7dbb3d23d34e274895133</entry>
  <entry></entry>
</row>
<row>
  <entry>icmw_32.dll</entry>
  <entry>Motion Wavelets (MWV1)</entry>
  <entry>c9618a8fc73ce219ba918e3e09e227f2</entry>
  <entry></entry>
</row>
<row>
  <entry>jp2avi.dll</entry>
  <entry>ImagePower MJPEG2000 (IPJ2)</entry>
  <entry>d860a11766da0d0ea064672c6833768b</entry>
  <entry><option>-vf flip</option></entry>
</row>
<row>
  <entry>m3jp2k32.dll</entry>
  <entry>Morgan MJPEG2000 (MJ2C)</entry>
  <entry>f3c174edcbaef7cb947d6357cdfde7ff</entry>
  <entry></entry>
</row>
<row>
  <entry>m3jpeg32.dll</entry>
  <entry>Morgan Motion JPEG Codec (MJPG)</entry>
  <entry>1cd13fff5960aa2aae43790242c323b1</entry>
  <entry></entry>
</row>
<row>
  <entry>mpg4c32.dll</entry>
  <entry>Microsoft MPEG-4 v1/v2</entry>
  <entry>b5791ea23f33010d37ab8314681f1256</entry>
  <entry></entry>
</row>
<row>
  <entry>tsccvid.dll</entry>
  <entry>TechSmith Camtasia Screen Codec (TSCC)</entry>
  <entry>8230d8560c41d444f249802a2700d1d5</entry>
  <entry></entry>
</row>
<row>
  <entry>vp31vfw.dll</entry>
  <entry>On2 Open Source VP3 Codec (VP31)</entry>
  <entry>845f3590ea489e2e45e876ab107ee7d2</entry>
  <entry></entry>
</row>
<row>
  <entry>vp4vfw.dll</entry>
  <entry>On2 VP4 Personal Codec (VP40)</entry>
  <entry>fc5480a482ccc594c2898dcc4188b58f</entry>
  <entry></entry>
</row>
<row>
  <entry>vp6vfw.dll</entry>
  <entry>On2 VP6 Personal Codec (VP60)</entry>
  <entry>04d635a364243013898fd09484f913fb</entry>
  <entry>stürzt unter Linux ab</entry>
</row>
<row>
  <entry>vp7vfw.dll</entry>
  <entry>On2 VP7 Personal Codec (VP70)</entry>
  <entry>cb4cc3d4ea7c94a35f1d81c3d750bc8d</entry>
  <entry>falscher FourCC?</entry>
</row>
<row>
  <entry>ViVD2.dll</entry>
  <entry>SoftMedia ViVD V2 Codec VfW (GXVE)</entry>
  <entry>a7b4bf5cac630bb9262c3f80d8a773a1</entry>
  <entry></entry>
</row>
</tbody>
</tgroup>
</informaltable>

Die erste Spalte enthält die Codec-Namen, die nach dem Parameter
<literal>codec</literal> übergeben werden sollten, wie:
<option>-xvfwopts codec=divx.dll</option>.
Der FourCC-Code, der von jedem Codec verwendet wird, steht in Klammern.
</para>
<informalexample>
<para>
Ein Beispiel mit VP3-Kompression:
<screen>mencoder dvd://2 -o title2.avi -ovc vfw -xvfwopts codec=vp31vfw.dll -oac copy</screen>
</para>
</informalexample>
</sect2>
</sect1>


<sect1 id="menc-feat-vcd-dvd">
<title>Verwenden des MEncoder zum Erzeugen VCD/SVCD/DVD-konformer Dateien.</title>

<sect2 id="menc-feat-vcd-dvd-constraints">
<title>Formatbeschränkungen</title>
<para>
  <application>MEncoder</application> ist in der Lage, MPEG-Dateien im VCD-, SCVD-
  und DVD-Format durch Verwendung der
  <systemitem class="library">libavcodec</systemitem>-Programmbibliothek
  zu erzeugen.
  Diese Dateien können danach im Zusammenhang mit
  <ulink url="http://www.gnu.org/software/vcdimager/vcdimager.html">vcdimager</ulink>
  oder
  <ulink url="http://dvdauthor.sourceforge.net/">dvdauthor</ulink>
  zum Erzeugen von Disks verwendet werden, die auf einem Standard Set-Top-Player
  abgespielt werden können.
</para>

<para>
  Die Formate DVD, SVCD und VCD sind starken Beschränkungen unterworfen.
  Es ist nur eine kleine Auswahl an encodierten Bildgrößen und Seitenverhältnissen
  verfügbar.
  Wenn dein Film nicht bereits die Anforderungen erfüllt, musst du das Bild
  skalieren, zuschneiden oder schwarze Ränder hinzufügen, um es konform zu machen.
</para>

<sect3 id="menc-feat-vcd-dvd-constraints-resolution">
<title>Formatbeschränkungen</title>

<informaltable frame="all">
<tgroup cols="9">
<thead>
    <row>
        <entry>Format</entry>
        <entry>Auflösung</entry>
        <entry>V. Codec</entry>
        <entry>V. Bitrate</entry>
        <entry>Samplerate</entry>
        <entry>A. Codec</entry>
        <entry>A. Bitrate</entry>
        <entry>FPS</entry>
        <entry>Seitenverhältnis</entry>
    </row>
</thead>
<tbody>
    <row>
        <entry>NTSC DVD</entry>
        <entry>720x480, 704x480, 352x480, 352x240</entry>
        <entry>MPEG-2</entry>
        <entry>9800 kbps</entry>
        <entry>48000 Hz</entry>
        <entry>AC3,PCM</entry>
        <entry>1536 kbps (max)</entry>
        <entry>30000/1001, 24000/1001</entry>
        <entry>4:3, 16:9 (nur für 720x480)</entry>
    </row>
    <row>
        <entry>NTSC DVD</entry>
        <entry>352x240<footnote id='fn-rare-resolutions'><para>
	  Diese Auflösungen werden selten für DVDs verwendet, da sie von
	  ziemlch niedriger Qualität sind.</para></footnote></entry>
        <entry>MPEG-1</entry>
        <entry>1856 kbps</entry>
        <entry>48000 Hz</entry>
        <entry>AC3,PCM</entry>
        <entry>1536 kbps (max)</entry>
        <entry>30000/1001, 24000/1001</entry>
        <entry>4:3, 16:9</entry>
    </row>
    <row>
        <entry>NTSC SVCD</entry>
        <entry>480x480</entry>
        <entry>MPEG-2</entry>
        <entry>2600 kbps</entry>
        <entry>44100 Hz</entry>
        <entry>MP2</entry>
        <entry>384 kbps (max)</entry>
        <entry>30000/1001</entry>
        <entry>4:3</entry>
    </row>
    <row>
        <entry>NTSC VCD</entry>
        <entry>352x240</entry>
        <entry>MPEG-1</entry>
        <entry>1150 kbps</entry>
        <entry>44100 Hz</entry>
        <entry>MP2</entry>
        <entry>224 kbps</entry>
        <entry>24000/1001, 30000/1001</entry>
        <entry>4:3</entry>
    </row>
    <row>
        <entry>PAL DVD</entry>
        <entry>720x576, 704x576, 352x576, 352x288</entry>
        <entry>MPEG-2</entry>
        <entry>9800 kbps</entry>
        <entry>48000 Hz</entry>
        <entry>MP2,AC3,PCM</entry>
        <entry>1536 kbps (max)</entry>
        <entry>25</entry>
        <entry>4:3, 16:9 (nur für 720x576)</entry>
    </row>
    <row>
        <entry>PAL DVD</entry>
        <entry>352x288<footnoteref linkend='fn-rare-resolutions'/></entry>
        <entry>MPEG-1</entry>
        <entry>1856 kbps</entry>
        <entry>48000 Hz</entry>
        <entry>MP2,AC3,PCM</entry>
        <entry>1536 kbps (max)</entry>
        <entry>25</entry>
        <entry>4:3, 16:9</entry>
    </row>
    <row>
        <entry>PAL SVCD</entry>
        <entry>480x576</entry>
        <entry>MPEG-2</entry>
        <entry>2600 kbps</entry>
        <entry>44100 Hz</entry>
        <entry>MP2</entry>
        <entry>384 kbps (max)</entry>
        <entry>25</entry>
        <entry>4:3</entry>
    </row>
    <row>
        <entry>PAL VCD</entry>
        <entry>352x288</entry>
        <entry>MPEG-1</entry>
        <entry>1152 kbps</entry>
        <entry>44100 Hz</entry>
        <entry>MP2</entry>
        <entry>224 kbps</entry>
        <entry>25</entry>
        <entry>4:3</entry>
    </row>
</tbody>
</tgroup>
</informaltable>

<para>
  Wenn ein Film ein 2.35:1 Seitenverhältnis hat (die meisten aktuellen Action-Filme),
  wirst du schwarze Ränder hinzufügen oder den Film auf 16:9 zuschneiden müssen,
  um eine DVD oder VCD herzustellen.
  Wenn du schwarze Ränder hinzufügst, versuche diese an 16-Pixel-Rändern
  auszurichten, um den Einfluß auf die Encodier-Performance zu minimieren.
  Zum Glück besitzen DVDs eine ausreichend hohe Bitrate, damit du dich
  nicht zu sehr um die Encodier-Effizienz sorgen musst. SVCD
  und VCD jedoch sind höchst mager an Bitrate und erfordern Aufwand, um akzeptable
  Qualität zu erreichen.
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-constraints-gop">
<title>GOP-Größenbeschränkungen</title>
<para>
  DVD, VCD und SVCD zwingen dich auch zu relativ niedrigen
  GOP-Größen (Group of Pictures).
  Für Material mit 30 fps ist die größte erlaubte GOP-Größe 18.
  Für 25 oder 24 fps ist das Maximum 15.
  Die GOP-Größe wird mittels der Option <option>keyint</option> gesetzt.
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-constraints-bitrate">
<title>Bitraten-Beschränkungen</title>
<para>
  VCD-Video muss bei CBR 1152 kbps sein.
  Zu dieser nach oben begrenzten Einschränkung kommt auch noch eine
  extrem niedrige vbv-Puffergröße von 327 Kilobit.
  SVCD erlaubt das Variieren der Video-Bitraten auf bis zu 2500 kbps,
  und eine etwas weniger restriktive vbv-Puffergröße von 917 Kilobit
  ist erlaubt.
  DVD-Video-Bitraten können sich bis auf irgendwo um die 9800 kbps
  einpegeln (wenngleich typische Bitraten etwa halb so groß sind),
  und die vbv-Puffergröße ist 1835 Kilobit.
</para>
</sect3>
</sect2>

<sect2 id="menc-feat-vcd-dvd-output">
<title>Output-Optionen</title>
<para>
  <application>MEncoder</application> besitzt Optionen zur Kontrolle des
  Output-Formats.
  Durch das Verwenden dieser Optionen können wir ihn anweisen, den
  korrekten Dateityp zu erzeugen.
</para>

<para>
  Die Optionen für VCD und SVCD werden xvcd und xsvcd genannt, weil sie
  erweiterte Formate sind.
  Sie sind nicht strikt Standard-konform, hauptsächlich weil der Output
  keine Scan-Offsets enthält.
  Wenn du ein SVCD-Image generieren musst, solltest du die Output-Datei
  dem
  <ulink url="http://www.gnu.org/software/vcdimager/vcdimager.html">vcdimager</ulink>
  übergeben.
</para>

<para>
  VCD:
  <screen>
  -of mpeg -mpegopts format=xvcd
  </screen>
</para>

<para>
  SVCD:
  <screen>
  -of mpeg -mpegopts format=xsvcd
  </screen>
</para>

<para>
  DVD:
  <screen>
  -of mpeg -mpegopts format=dvd
  </screen>
</para>

<para>
  DVD mit NTSC-Pullup:
  <screen>
  -of mpeg -mpegopts format=dvd:telecine -ofps 24000/1001
  </screen>
  Dies erlaubt 24000/1001 fps progressive-Inhalt bei 30000/1001
  fps encodiert zu werden, wobei die DVD-Konformität erhalten bleibt.
</para>

<sect3 id="menc-feat-vcd-dvd-output-aspect">
<title>Seitenverhältnis</title>
<para>
  Der Parameter für das Seitenverhältnis von <option>-lavcopts</option> wird zum Encodieren
  des Seitenverhältnisses einer Datei verwendet.
  Während des Playbacks wird das Seitenverhältnis dazu benutzt, die korrekte
  Größe des Videos wieder herzustellen.
</para>

<para>
  16:9 oder "Breitbild"
  <screen>
  -lavcopts aspect=16/9
  </screen>
</para>

<para>
  4:3 oder "Vollbild"
  <screen>
  -lavcopts aspect=4/3
  </screen>
</para>

<para>
  2.35:1 oder "Cinemascope" NTSC
  <screen>
  -vf scale=720:368,expand=720:480 -lavcopts aspect=16/9
  </screen>
  Um die korrekte Skalierungsgröße zu berechnen, verwende die
  erweiterte NTSC-Breite von 854/2.35 = 368
</para>

<para>
  2.35:1 oder "Cinemascope" PAL
  <screen>
  -vf scale="720:432,expand=720:576 -lavcopts aspect=16/9
  </screen>
  Um die korrekte Skalierungsgröße zu berechnen, verwende die
  erweiterte PAL-Breite von 1024/2.35 = 432
</para>

</sect3>

<sect3 id="menc-feat-vcd-dvd-a-v-sync">
<title>Aufrechterhalten der A/V-Synchronisation</title>
<para>
  Um die Audio-/Video-Synchronisation während der kompletten
  Encodierung aufrechtzuerhalten, muss
  <application>MEncoder</application> Frames auslassen oder duplizieren.
  Dies funktioniert beim Muxen in eine AVI-Datei ziemlich gut,
  aber meist schlägt das Aufrechterhalten der A/V-Synchronisation mit
  anderen Muxern wie etwa MPEG garantiert fehl.
  Dies ist der Grund, weshalb es nötig ist, den
  <option>harddup</option>-Video-Filter am Ende der Filterkette anzuhängen,
  um diese Art Problem zu vermeiden.
  Du findest mehr technische Informationen zu <option>harddup</option>
  im Abschnitt
  <link linkend="menc-feat-dvd-mpeg4-muxing-filter-issues">Verbessern der Mux- und A/V-Synchronisationszuverlässigkeit</link>
  oder in der Manpage.
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-output-srate">
<title>Sampleraten-Konvertierung</title>
<para>
  Wenn die Audio-Samplerate in der Originaldatei nicht dieselbe wie die
  vom Zielformat angeforderte ist, wird eine Sampleraten-Konvertierung
  erforderlich.
  Dies wird erreicht, indem man die Option <option>-srate</option> und
  den <option>-af lavcresample</option> Audio-Filter zusammen
  anwedet.
  </para>
  <para>
  DVD:
  <screen>
  -srate 48000 -af lavcresample=48000
  </screen>
</para>
<para>
  VCD und SVCD:
  <screen>
  -srate 44100 -af lavcresample=44100
  </screen>
  </para>
</sect3>
</sect2>

<sect2 id="menc-feat-vcd-dvd-lavc">
<title>Verwenden des libavcodec zur VCD/SVCD/DVD-Encodierung</title>

<sect3 id="menc-feat-vcd-dvd-lavc-intro">
<title>Einführung</title>
<para>
  <systemitem class="library">libavcodec</systemitem> kann verwendet
  werden, um ein VCD/SVCD/DVD-konformes Video durch die Anwendung der
  passenden Optionen zu erzeugen.
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-lavc-options">
<title>lavcopts</title>
<para>
  Dies ist eine Liste von Feldern in <option>-lavcopts</option>, die du
  möglicherweise ändern musst, um einen für VCD, SVCD
  oder DVD konformen Film herzustellen:
</para>

<itemizedlist>
<listitem><para>
  <emphasis role="bold">acodec</emphasis>:
  <option>mp2</option> für VCD, SVCD oder PAL DVD;
  <option>ac3</option> wird am häufigsten für DVD verwendet.
  PCM-Audio kann auch für DVD verwendet werden, aber dies ist meistens
  eine riesen Platzverschwendung.
  Beachte, dass MP3-Audio nicht konform für irgendeines dieser Formate
  ist, aber Player haben oft ohnehin kein Problem, es abzuspielen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">abitrate</emphasis>:
  224 für VCD; bis zu 384 für SVCD; bis zu 1536 für  DVD, aber
  übliche Werte reichen von 192 kbps für Stereo bis 384 kbps für
  5.1-Kanal-Sound.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vcodec</emphasis>:
  <option>mpeg1video</option> für VCD;
  <option>mpeg2video</option> für SVCD;
  <option>mpeg2video</option> wird gewöhnlich für DVD verwendet, man kann aber auch
  <option>mpeg1video</option> für CIF-Auflösungen verwenden.
</para></listitem>

<listitem><para>
  <emphasis role="bold">keyint</emphasis>:
  Angewandt, um die GOP-Größe zu setzen.
  18 für Material mit 30fps oder 15 für Material mit 25/24 fps.
  Kommerzielle Hersteller scheinen Keyframe-Intervalle von 12 zu bevorzugen.
  Es ist möglich, dies viel größer zu machen und dennoch die Kompatibilität
  zu den meisten Player zu behalten.
  Ein <option>keyint</option> von 25 sollte nie irgendwelche Probleme machen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vrc_buf_size</emphasis>:
  327 für VCD, 917 für SVCD und 1835 für DVD.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vrc_minrate</emphasis>:
  1152 für VCD. kann für SVCD und DVD so gelassen werden.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vrc_maxrate</emphasis>:
  1152 für VCD; 2500 für SVCD; 9800 für DVD.
  Für SVCD und DVD könntest du niedrigere Werte verwenden, abhängig von
  deinen persönlichen Vorlieben und Anforderungen.
</para></listitem>

<listitem><para>
  <emphasis role="bold">vbitrate</emphasis>:
  1152 für VCD;
  bis zu 2500 für SVCD;
  bis zu 9800 für DVD.
  Für letztere zwei Formate sollte vbitrate basierend auf persönliche
  Vorlieben gesetzt werden.
  Zum Beispiel, wenn du darauf bestehst, 20 Stunden oder so passend auf
  eine DVD zu bringen, könntest du vbitrate=400 benutzen.
  Die sich daraus ergebende Video-Qualität würde womöglich äußerst mies.
  Wenn du versuchst, die maximal mögliche Qualität auf eine DVD zu quetschen,
  nimm vbitrate=9800, aber sei gewarnt, dass dich dies zu weniger als
  einer Stunde Video auf einer Single-Layer DVD zwingen würde.
</para></listitem>
</itemizedlist>
</sect3>

<sect3 id="menc-feat-vcd-dvd-lavc-examples">
<title>Beispiele</title>
<para>
  Dies ist eine typische Zusammenstellung von mindestens zu verwendenden
  <option>-lavcopts</option>-Optionen zum Encodieren eines Videos:
</para>
<para>
  VCD:
  <screen>
  -lavcopts vcodec=mpeg1video:vrc_buf_size=327:vrc_minrate=1152:\
  vrc_maxrate=1152:vbitrate=1152:keyint=15:acodec=mp2
  </screen>
</para>

<para>
  SVCD:
  <screen>
  -lavcopts vcodec=mpeg2video:vrc_buf_size=917:vrc_maxrate=2500:vbitrate=1800:\
  keyint=15:acodec=mp2
  </screen>
</para>

<para>
  DVD:
  <screen>
  -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:\
  keyint=15:acodec=ac3
  </screen>
</para>

</sect3>

<sect3 id="menc-feat-vcd-dvd-lavc-advanced">
<title>Erweiterte Optionen</title>
<para>
  Für das Encodieren höherer Qualität könntest du auch qualitätssteigernde
  Optionen an lavcopts anfügen, wie etwa <option>trell</option>,
  <option>mbd=2</option> und weitere.
  Beachte, dass <option>qpel</option> und <option>v4mv</option>, obwohl
  oft bei MPEG-4 nützlich, nicht auf MPEG-1 oder MPEG-2 anwendbar sind.
  Außerdem, wenn du versuchst, eine sehr hochwertige DVD-Encodierung zu
  machen, kann es nützlich sein, <option>dc=10</option> an lavcopts
  anzufügen.
  Wobei dies helfen könnte, das Auftreten von Blöcken in fahl-farbenen
  Bereichen zu reduzieren.
  Zusammenfassend ist dies ein Beispiel einer Zusammenstellung von lavcopts für
  für eine höherwertige DVD:
</para>

<para>
  <screen>
  -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=8000:\
  keyint=15:trell:mbd=2:precmp=2:subcmp=2:cmp=2:dia=-10:predia=-10:cbp:mv0:\
  vqmin=1:lmin=1:dc=10
  </screen>
</para>

</sect3>
</sect2>

<sect2 id="menc-feat-vcd-dvd-audio">
<title>Encodieren von Audio</title>
<para>
  VCD und SVCD unterstützen MPEG-1 Layer II Audio, indem sie einen
  MP2-Encoder von
  <systemitem class="library">toolame</systemitem>,
  <systemitem class="library">twolame</systemitem>,
  oder <systemitem class="library">libavcodec</systemitem>
  verwenden.
  Der libavcodec MP2 ist weit davon entfernt, so gut zu sein wie die
  anderen zwei Bibliotheken, dennoch sollte er immer verfügbar sein.
  VCD unterstützt nur Audio mit konstanten Bitraten (CBR) wogegen SVCD
  auch variable Bitraten (VBR) unterstützt.
  Sei vorsichtig, wenn du VBR benutzt, weil einige schlechte
  Standalone-Player diese nicht so gut unterstützen könnten.
</para>

<para>
  Für DVD-Audio wird der AC3-Codec von
  <systemitem class="library">libavcodec</systemitem>
  verwendet.
</para>

<sect3 id="menc-feat-vcd-dvd-audio-toolame">
<title>toolame</title>
<para>
  Für VCD und SVCD:
  <screen>
  -oac toolame -toolameopts br=224
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-audio-twolame">
<title>twolame</title>
<para>
  Für VCD und SVCD:
  <screen>
  -oac twolame -twolameopts br=224
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-audio-lavc">
<title>libavcodec</title>
<para>
  Für DVD mit 2-Kanal-Sound:
  <screen>
  -oac lavc -lavcopts acodec=ac3:abitrate=192
  </screen>
</para>
<para>
  Für DVD mit 5.1-Kanal-Sound:
  <screen>
  -channels 6 -oac lavc -lavcopts acodec=ac3:abitrate=384
  </screen>
</para>
<para>
  Für VCD und SVCD:
  <screen>
  -oac lavc -lavcopts acodec=mp2:abitrate=224
  </screen>
</para>
</sect3>

</sect2>

<sect2 id="menc-feat-vcd-dvd-all">
<title>Zusammenfassung</title>
<para>
  Diese Sektion zeigt einige komplette Befehle zum Erzeugen von
  VCD/SVCD/DVD-konformen Videos.
</para>

<sect3 id="menc-feat-vcd-dvd-all-pal-dvd">
<title>PAL DVD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=dvd -vf scale=720:576,\
  harddup -srate 48000 -af lavcresample=48000 -lavcopts vcodec=mpeg2video:\
  vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:keyint=15:acodec=ac3:\
  abitrate=192:aspect=16/9 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-ntsc-dvd">
<title>NTSC DVD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=dvd -vf scale=720:480,\
  harddup -srate 48000 -af lavcresample=48000 -lavcopts vcodec=mpeg2video:\
  vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=5000:keyint=18:acodec=ac3:\
  abitrate=192:aspect=16/9 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-pal-ac3-copy">
<title>PAL AVI mit enthaltenem AC3 Audio nach DVD</title>
<para>
  Hat die Quelle bereits AC3-Audio, nimm -oac copy anstatt es
  erneut zu encodieren.
  <screen>
  mencoder -oac copy -ovc lavc -of mpeg -mpegopts format=dvd -vf scale=720:576,\
  harddup -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:\
  vbitrate=5000:keyint=15:aspect=16/9 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-ntsc-ac3-copy">
<title>NTSC AVI mit AC3-Ton nach DVD</title>
<para>
  Hat die Quelle bereits AC3-Audio und ist NTSC @ 24000/1001 fps:
  <screen>
  mencoder -oac copy -ovc lavc -of mpeg -mpegopts format=dvd:telecine \
  -vf scale=720:480,harddup -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:\
  vrc_maxrate=9800:vbitrate=5000:keyint=15:aspect=16/9 -ofps 24000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-pal-svcd">
<title>PAL SVCD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xsvcd -vf \
  scale=480:576,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg2video:mbd=2:keyint=15:vrc_buf_size=917:vrc_minrate=600:\
  vbitrate=2500:vrc_maxrate=2500:acodec=mp2:abitrate=224 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-ntsc-svcd">
<title>NTSC SVCD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xsvcd  -vf \
  scale=480:480,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg2video:mbd=2:keyint=18:vrc_buf_size=917:vrc_minrate=600:\
  vbitrate=2500:vrc_maxrate=2500:acodec=mp2:abitrate=224 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-pal-vcd">
<title>PAL VCD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xvcd -vf \
  scale=352:288,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg1video:keyint=15:vrc_buf_size=327:vrc_minrate=1152:vbitrate=1152:\
  vrc_maxrate=1152:acodec=mp2:abitrate=224 -ofps 25 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

<sect3 id="menc-feat-vcd-dvd-all-ntsc-vcd">
<title>NTSC VCD</title>
<para>
  <screen>
  mencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=xvcd -vf \
  scale=352:240,harddup -srate 44100 -af lavcresample=44100 -lavcopts \
  vcodec=mpeg1video:keyint=18:vrc_buf_size=327:vrc_minrate=1152:vbitrate=1152:\
  vrc_maxrate=1152:acodec=mp2:abitrate=224 -ofps 30000/1001 \
  -o <replaceable>movie.mpg</replaceable> <replaceable>movie.avi</replaceable>
  </screen>
</para>
</sect3>

</sect2>

</sect1>

</chapter>
